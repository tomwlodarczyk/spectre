<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - b1f4fe8326c5dc9de3d64954e9325e08a2677cfd - /work/build_Debug_clang/docs/xml/tutorial_orientations.xml</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title"> SpECTRE Documentation Coverage Report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">work/build_Debug_clang/docs/xml</a> - tutorial_orientations.xml</td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
             <td class="headerItem">Commit:</td>
             <td class="headerValue"><a target="_blank" href="https://github.com/sxs-collaboration/spectre/commit/b1f4fe8326c5dc9de3d64954e9325e08a2677cfd">b1f4fe8326c5dc9de3d64954e9325e08a2677cfd</a></td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2019-10-20 17:39:50</td>
            <td></td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<span class="lineNum">       1 </span><span class="lineCov">          1 : &lt;?xml version='1.0' encoding='UTF-8' standalone='no'?&gt;</span>
<span class="lineNum">       2 </span>            : &lt;doxygen xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;compound.xsd&quot; version=&quot;1.8.13&quot;&gt;
<span class="lineNum">       3 </span>            :   &lt;compounddef id=&quot;tutorial_orientations&quot; kind=&quot;page&quot;&gt;
<span class="lineNum">       4 </span>            :     &lt;compoundname&gt;tutorial_orientations&lt;/compoundname&gt;
<span class="lineNum">       5 </span>            :     &lt;title&gt;OrientationMap&lt;/title&gt;
<span class="lineNum">       6 </span>            :     &lt;detaileddescription&gt;
<span class="lineNum">       7 </span>            : &lt;para&gt;&lt;heading level=&quot;3&quot;&gt;Introduction&lt;/heading&gt;
<span class="lineNum">       8 </span>            : &lt;/para&gt;&lt;para&gt;Each element in a domain has a set of internal directions which it uses for computations in its own local coordinate system. These are referred to as the logical directions &lt;formula id=&quot;278&quot;&gt;$\xi$&lt;/formula&gt;, &lt;formula id=&quot;297&quot;&gt;$\eta$&lt;/formula&gt;, and &lt;formula id=&quot;253&quot;&gt;$\zeta$&lt;/formula&gt;, where &lt;formula id=&quot;278&quot;&gt;$\xi$&lt;/formula&gt; is the first dimension, &lt;formula id=&quot;297&quot;&gt;$\eta$&lt;/formula&gt; is the second dimension, and &lt;formula id=&quot;253&quot;&gt;$\zeta$&lt;/formula&gt; is the third dimension. In a domain with multiple elements, the logical directions are not necessarily aligned on the interfaces between two elements, as shown in the figure below. As certain operations (e.g. fluxes, limiting) communicate information across the boundaries of adjacent elements, there needs to be a class that takes into account the relative orientations of elements which neighbor each other. This class is OrientationMap.&lt;/para&gt;&lt;para&gt;&lt;heading level=&quot;3&quot;&gt;OrientationMaps between Blocks&lt;/heading&gt;
<span class="lineNum">       9 </span>            : &lt;/para&gt;&lt;para&gt;Each &lt;ref refid=&quot;classBlock&quot; kindref=&quot;compound&quot;&gt;Block&lt;/ref&gt; in a &lt;ref refid=&quot;classDomain&quot; kindref=&quot;compound&quot;&gt;Domain&lt;/ref&gt; has a set of BlockNeighbors, which each hold an OrientationMap. In this scenario, the &lt;ref refid=&quot;classBlock&quot; kindref=&quot;compound&quot;&gt;Block&lt;/ref&gt; is referred to as the host, and the OrientationMap held by each &lt;ref refid=&quot;classBlockNeighbor&quot; kindref=&quot;compound&quot;&gt;BlockNeighbor&lt;/ref&gt; is referred to as &amp;quot;the
<span class="lineNum">      10 </span>            : orientation the BlockNeighbor has with respect to the host Block.&amp;quot; This is a convention, so we give an example of constructing and assigning the correct OrientationMaps:&lt;/para&gt;&lt;para&gt;&lt;image type=&quot;html&quot; name=&quot;twocubes.png&quot;&gt;Two neighboring blocks.&lt;/image&gt;
<span class="lineNum">      11 </span>            :  In the image above, we see a domain decomposition into two Blocks, which have their logical axes rotated relative to one another. With the left block as the host &lt;ref refid=&quot;classBlock&quot; kindref=&quot;compound&quot;&gt;Block&lt;/ref&gt;, we see that it has a neighbor in the &lt;formula id=&quot;1544&quot;&gt;$+\xi$&lt;/formula&gt; direction. The host &lt;ref refid=&quot;classBlock&quot; kindref=&quot;compound&quot;&gt;Block&lt;/ref&gt; holds a &lt;computeroutput&gt;&lt;ref refid=&quot;cpp/container/unordered_map&quot; kindref=&quot;compound&quot; external=&quot;/work/spectre/docs/config/cppreference-doxygen-web.tag.xml&quot;&gt;std::unordered_map&lt;/ref&gt;&lt;/computeroutput&gt; from Directions to BlockNeighbors; the &lt;ref refid=&quot;classBlockNeighbor&quot; kindref=&quot;compound&quot;&gt;BlockNeighbor&lt;/ref&gt; itself holds an OrientationMap that determines the mapping from each logical direction in the host &lt;ref refid=&quot;classBlock&quot; kindref=&quot;compound&quot;&gt;Block&lt;/ref&gt; to that in the neighboring &lt;ref refid=&quot;classBlock&quot; kindref=&quot;compound&quot;&gt;Block&lt;/ref&gt;. That is, the OrientationMap takes as input local information (i.e. logical directions in the host&amp;apos;s coordinate system) and returns neighbor information (i.e. logical directions in the neighbor&amp;apos;s coordinate system). An OrientationMap is constructed by passing in the block neighbor directions that correspond to the &lt;formula id=&quot;1544&quot;&gt;$+\xi$&lt;/formula&gt;, &lt;formula id=&quot;1545&quot;&gt;$+\eta$&lt;/formula&gt;, &lt;formula id=&quot;258&quot;&gt;$+\zeta$&lt;/formula&gt; directions in the host. In this case, these directions in the host map to the &lt;formula id=&quot;258&quot;&gt;$+\zeta$&lt;/formula&gt;, &lt;formula id=&quot;1544&quot;&gt;$+\xi$&lt;/formula&gt;, &lt;formula id=&quot;1545&quot;&gt;$+\eta$&lt;/formula&gt; directions in the neighbor, respectively. This &lt;ref refid=&quot;classBlockNeighbor&quot; kindref=&quot;compound&quot;&gt;BlockNeighbor&lt;/ref&gt; thus holds the OrientationMap constructed with the list ( &lt;formula id=&quot;258&quot;&gt;$+\zeta$&lt;/formula&gt;, &lt;formula id=&quot;1544&quot;&gt;$+\xi$&lt;/formula&gt;, &lt;formula id=&quot;1545&quot;&gt;$+\eta$&lt;/formula&gt;). With the right block as the host block, we see that it has a &lt;ref refid=&quot;classBlockNeighbor&quot; kindref=&quot;compound&quot;&gt;BlockNeighbor&lt;/ref&gt; in the &lt;formula id=&quot;1546&quot;&gt;$-\zeta$&lt;/formula&gt; direction, and the OrientationMap held by this &lt;ref refid=&quot;classBlockNeighbor&quot; kindref=&quot;compound&quot;&gt;BlockNeighbor&lt;/ref&gt; is the one constructed with the array ( &lt;formula id=&quot;1545&quot;&gt;$+\eta$&lt;/formula&gt;, &lt;formula id=&quot;258&quot;&gt;$+\zeta$&lt;/formula&gt;, &lt;formula id=&quot;1544&quot;&gt;$+\xi$&lt;/formula&gt;). For convenience, OrientationMap has a method &lt;computeroutput&gt;inverse_map&lt;/computeroutput&gt; which returns the OrientationMap that takes as input neighbor information and returns local information.&lt;/para&gt;&lt;para&gt;OrientationMaps need to be provided for each &lt;ref refid=&quot;classBlockNeighbor&quot; kindref=&quot;compound&quot;&gt;BlockNeighbor&lt;/ref&gt; in each direction for each &lt;ref refid=&quot;classBlock&quot; kindref=&quot;compound&quot;&gt;Block&lt;/ref&gt;. This quickly becomes too large of a number to determine by hand as the number of Blocks and the number of dimensions increases. A remedy to this problem is the corner numbering scheme.&lt;/para&gt;&lt;para&gt;&lt;heading level=&quot;3&quot;&gt;Encoding &lt;ref refid=&quot;classBlockNeighbor&quot; kindref=&quot;compound&quot;&gt;BlockNeighbor&lt;/ref&gt; information using Corner Orderings and Numberings&lt;/heading&gt;
<span class="lineNum">      12 </span>            : &lt;/para&gt;&lt;para&gt;The orientation of the &lt;formula id=&quot;1547&quot;&gt;${dim}$&lt;/formula&gt; logical directions within each element determines an ordering of the &lt;formula id=&quot;1548&quot;&gt;$2^{dim}$&lt;/formula&gt; vertices of that element. This is called the local corner numbering scheme (Local CNS) with respect to that element. We give the ordering of the local corners below for the case of a three-dimensional element:&lt;/para&gt;&lt;para&gt;&lt;image type=&quot;html&quot; name=&quot;onecube_numbered.png&quot;&gt;The local corner numbering.&lt;/image&gt;
<span class="lineNum">      13 </span>            :  &lt;programlisting&gt;&lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;Corner&lt;sp/&gt;0&lt;sp/&gt;is&lt;sp/&gt;the&lt;sp/&gt;location&lt;sp/&gt;of&lt;sp/&gt;the&lt;sp/&gt;lower&lt;sp/&gt;xi,&lt;sp/&gt;lower&lt;sp/&gt;eta,&lt;sp/&gt;lower&lt;sp/&gt;zeta&lt;sp/&gt;corner.&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      14 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;Corner&lt;sp/&gt;1&lt;sp/&gt;is&lt;sp/&gt;the&lt;sp/&gt;location&lt;sp/&gt;of&lt;sp/&gt;the&lt;sp/&gt;upper&lt;sp/&gt;xi,&lt;sp/&gt;lower&lt;sp/&gt;eta,&lt;sp/&gt;lower&lt;sp/&gt;zeta&lt;sp/&gt;corner.&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      15 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;Corner&lt;sp/&gt;2&lt;sp/&gt;is&lt;sp/&gt;the&lt;sp/&gt;location&lt;sp/&gt;of&lt;sp/&gt;the&lt;sp/&gt;lower&lt;sp/&gt;xi,&lt;sp/&gt;upper&lt;sp/&gt;eta,&lt;sp/&gt;lower&lt;sp/&gt;zeta&lt;sp/&gt;corner.&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      16 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;Corner&lt;sp/&gt;3&lt;sp/&gt;is&lt;sp/&gt;the&lt;sp/&gt;location&lt;sp/&gt;of&lt;sp/&gt;the&lt;sp/&gt;upper&lt;sp/&gt;xi,&lt;sp/&gt;upper&lt;sp/&gt;eta,&lt;sp/&gt;lower&lt;sp/&gt;zeta&lt;sp/&gt;corner.&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      17 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;Corner&lt;sp/&gt;4&lt;sp/&gt;is&lt;sp/&gt;the&lt;sp/&gt;location&lt;sp/&gt;of&lt;sp/&gt;the&lt;sp/&gt;lower&lt;sp/&gt;xi,&lt;sp/&gt;lower&lt;sp/&gt;eta,&lt;sp/&gt;upper&lt;sp/&gt;zeta&lt;sp/&gt;corner.&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      18 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;Corner&lt;sp/&gt;5&lt;sp/&gt;is&lt;sp/&gt;the&lt;sp/&gt;location&lt;sp/&gt;of&lt;sp/&gt;the&lt;sp/&gt;upper&lt;sp/&gt;xi,&lt;sp/&gt;lower&lt;sp/&gt;eta,&lt;sp/&gt;upper&lt;sp/&gt;zeta&lt;sp/&gt;corner.&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      19 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;Corner&lt;sp/&gt;6&lt;sp/&gt;is&lt;sp/&gt;the&lt;sp/&gt;location&lt;sp/&gt;of&lt;sp/&gt;the&lt;sp/&gt;lower&lt;sp/&gt;xi,&lt;sp/&gt;upper&lt;sp/&gt;eta,&lt;sp/&gt;upper&lt;sp/&gt;zeta&lt;sp/&gt;corner.&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      20 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;Corner&lt;sp/&gt;7&lt;sp/&gt;is&lt;sp/&gt;the&lt;sp/&gt;location&lt;sp/&gt;of&lt;sp/&gt;the&lt;sp/&gt;upper&lt;sp/&gt;xi,&lt;sp/&gt;upper&lt;sp/&gt;eta,&lt;sp/&gt;upper&lt;sp/&gt;zeta&lt;sp/&gt;corner.&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      21 </span>            : &lt;/programlisting&gt;&lt;/para&gt;&lt;para&gt;What remains is to endow the domain decomposition with a global corner numbering (Global CNS). We give an example below:&lt;/para&gt;&lt;para&gt;&lt;image type=&quot;html&quot; name=&quot;twocubes_numbered.png&quot;&gt;A global corner numbering.&lt;/image&gt;
<span class="lineNum">      22 </span>            :  In the image above, we see that each vertex of the two-block domain has been assigned a number. Although each block has eight corners, four are shared among them, so there are only twelve unique corners in this domain. Any numbering may be used in the global corner numbering, so long as the each distinct corner is given a single distinct corner number.&lt;/para&gt;&lt;para&gt;&lt;simplesect kind=&quot;note&quot;&gt;&lt;para&gt;This Global CNS assumes that there is no additional identifying of faces with one another for periodic boundary conditions. That is, each element must have &lt;formula id=&quot;1548&quot;&gt;$2^{dim}$&lt;/formula&gt; distinct corner numbers. If you wish to additionally identify faces of the same block with each other, that must be done in an additional step. This step is explained in the &amp;quot;Setting Periodic Boundary
<span class="lineNum">      23 </span>            : Conditions&amp;quot; section.&lt;/para&gt;&lt;/simplesect&gt;
<span class="lineNum">      24 </span>            : &lt;heading level=&quot;3&quot;&gt;The Ordered Subset of the Global CNS (Subset CNS):&lt;/heading&gt;
<span class="lineNum">      25 </span>            : &lt;/para&gt;&lt;para&gt;With the Global CNS in hand, each &lt;ref refid=&quot;classBlock&quot; kindref=&quot;compound&quot;&gt;Block&lt;/ref&gt; inherits an ordered subset of Global CNS. The ordering in this set is determined by the ordering of the Local CNS, and the elements of the set determined by how one assigned the Global CNS to the &lt;ref refid=&quot;classDomain&quot; kindref=&quot;compound&quot;&gt;Domain&lt;/ref&gt;. For the image above, the Subset CNS corresponding to the left block is {0, 1, 3, 4, 6, 7, 9, 10}, while the Subset CNS corresponding to the right block is {1, 4, 7, 10, 2, 5, 8, 11}. This ordering of the Subset CNS encodes the relative orientations between each &lt;ref refid=&quot;classBlock&quot; kindref=&quot;compound&quot;&gt;Block&lt;/ref&gt;. Subset CNSs need to be provided for each &lt;ref refid=&quot;classBlock&quot; kindref=&quot;compound&quot;&gt;Block&lt;/ref&gt; in a &lt;ref refid=&quot;classDomain&quot; kindref=&quot;compound&quot;&gt;Domain&lt;/ref&gt;. It turns out that for very regular domains, (i.e. spherical or rectilinear) we can generate the appropriate Subset CNSs. As this is a conceptual tutorial, how to construct these domains in SpECTRE is described in the &lt;ref refid=&quot;tutorial_domain_creation&quot; kindref=&quot;compound&quot;&gt;Domain Creation&lt;/ref&gt; tutorial.&lt;/para&gt;&lt;para&gt;&lt;heading level=&quot;3&quot;&gt;Explanation of the Algorithms in DomainHelpers:&lt;/heading&gt;
<span class="lineNum">      26 </span>            : &lt;/para&gt;&lt;para&gt;For illustrative purposes, we will use the following &lt;ref refid=&quot;classDomain&quot; kindref=&quot;compound&quot;&gt;Domain&lt;/ref&gt; composed of two Blocks as described above as an example. Because there are 12 corners in this &lt;ref refid=&quot;classDomain&quot; kindref=&quot;compound&quot;&gt;Domain&lt;/ref&gt;, we will arbitrarily assign a unique id to each corner. Knowing the orientation of the logical axes within a block, we construct a Subset CNS for each &lt;ref refid=&quot;classBlock&quot; kindref=&quot;compound&quot;&gt;Block&lt;/ref&gt;.&lt;linebreak/&gt;
<span class="lineNum">      27 </span>            :  Here is one possible result, given some relative orientation between the blocks:&lt;/para&gt;&lt;para&gt;&lt;programlisting&gt;&lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;Block1:&lt;sp/&gt;{0,&lt;sp/&gt;1,&lt;sp/&gt;3,&lt;sp/&gt;4,&lt;sp/&gt;6,&lt;sp/&gt;7,&lt;sp/&gt;9,&lt;sp/&gt;10}&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      28 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;Block2:&lt;sp/&gt;{1,&lt;sp/&gt;4,&lt;sp/&gt;7,&lt;sp/&gt;10,&lt;sp/&gt;2,&lt;sp/&gt;5,&lt;sp/&gt;8,&lt;sp/&gt;11}&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      29 </span>            : &lt;/programlisting&gt;&lt;/para&gt;&lt;para&gt;The values of the ids only serve to identify which corners are unique and which are shared. This is determined by the Global CNS. The order of the ids in the list is determined by the Local CNS. We take advantage of the fact that the array index of the global corner id is the number of the corner in the local CNS.&lt;/para&gt;&lt;para&gt;The algorithm begins by determining the shared corners between the Blocks:&lt;/para&gt;&lt;para&gt;&lt;programlisting&gt;&lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;result:&lt;sp/&gt;{1,&lt;sp/&gt;4,&lt;sp/&gt;7,&lt;sp/&gt;10}&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      30 </span>            : &lt;/programlisting&gt;&lt;/para&gt;&lt;para&gt;The next step is to determine the local ids of these shared global ids:&lt;/para&gt;&lt;para&gt;&lt;programlisting&gt;&lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;Block1&lt;sp/&gt;result:&lt;sp/&gt;{1,3,5,7}&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      31 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;Block2&lt;sp/&gt;result:&lt;sp/&gt;{0,1,2,3}&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      32 </span>            : &lt;/programlisting&gt;&lt;/para&gt;&lt;para&gt;The next step is to convert these ids into their binary representation. For reference, we give the binary representation for each number 0-7:&lt;/para&gt;&lt;para&gt;&lt;programlisting&gt;&lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;Corner&lt;sp/&gt;0:&lt;sp/&gt;000&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      33 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;Corner&lt;sp/&gt;1:&lt;sp/&gt;001&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      34 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;Corner&lt;sp/&gt;2:&lt;sp/&gt;010&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      35 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;Corner&lt;sp/&gt;3:&lt;sp/&gt;011&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      36 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;Corner&lt;sp/&gt;4:&lt;sp/&gt;100&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      37 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;Corner&lt;sp/&gt;5:&lt;sp/&gt;101&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      38 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;Corner&lt;sp/&gt;6:&lt;sp/&gt;110&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      39 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;Corner&lt;sp/&gt;7:&lt;sp/&gt;111&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      40 </span>            : &lt;/programlisting&gt;&lt;/para&gt;&lt;para&gt;Here 0 and 1 indicate lower and upper in the corresponding axis (zeta, eta, xi), respectively, and the ordering has been reversed so that the rightmost column corresponds to the xi position and the leftmost column to the zeta position. Returning to the example at hand, we have:&lt;/para&gt;&lt;para&gt;&lt;programlisting&gt;&lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;Block1&lt;sp/&gt;result:&lt;sp/&gt;{001,011,101,111}&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      41 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;Block2&lt;sp/&gt;result:&lt;sp/&gt;{000,001,010,011}&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      42 </span>            : &lt;/programlisting&gt;&lt;/para&gt;&lt;para&gt;Note that we can now read off the shared face relative to each &lt;ref refid=&quot;classBlock&quot; kindref=&quot;compound&quot;&gt;Block&lt;/ref&gt; easily:&lt;/para&gt;&lt;para&gt;&lt;programlisting&gt;&lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;Block1&lt;sp/&gt;result:&lt;sp/&gt;Upper&lt;sp/&gt;xi&lt;sp/&gt;(All&lt;sp/&gt;binary&lt;sp/&gt;Block1&lt;sp/&gt;ids&lt;sp/&gt;have&lt;sp/&gt;a&lt;sp/&gt;1&lt;sp/&gt;in&lt;sp/&gt;the&lt;sp/&gt;third&lt;sp/&gt;position)&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      43 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;Block2&lt;sp/&gt;result:&lt;sp/&gt;Lower&lt;sp/&gt;zeta&lt;sp/&gt;(All&lt;sp/&gt;binary&lt;sp/&gt;Block2&lt;sp/&gt;ids&lt;sp/&gt;have&lt;sp/&gt;a&lt;sp/&gt;0&lt;sp/&gt;in&lt;sp/&gt;the&lt;sp/&gt;first&lt;sp/&gt;position)&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      44 </span>            : &lt;/programlisting&gt;&lt;/para&gt;&lt;para&gt;Now we know that &lt;computeroutput&gt;&lt;ref refid=&quot;classDirection&quot; kindref=&quot;compound&quot;&gt;Direction&lt;/ref&gt;&amp;lt;3&amp;gt;::upper_xi()&lt;/computeroutput&gt; in Block1 corresponds to &lt;computeroutput&gt;&lt;ref refid=&quot;classDirection&quot; kindref=&quot;compound&quot;&gt;Direction&lt;/ref&gt;&amp;lt;3&amp;gt;::lower_zeta().opposite()&lt;/computeroutput&gt; in Block2.&lt;/para&gt;&lt;para&gt;The use of &lt;computeroutput&gt;.opposite()&lt;/computeroutput&gt; is a result of the Directions to a &lt;ref refid=&quot;classBlock&quot; kindref=&quot;compound&quot;&gt;Block&lt;/ref&gt; face being anti-parallel because each &lt;ref refid=&quot;classBlock&quot; kindref=&quot;compound&quot;&gt;Block&lt;/ref&gt; lies on the opposite side of the shared face. &lt;linebreak/&gt;
<span class="lineNum">      45 </span>            : &lt;/para&gt;&lt;para&gt;The remaining two correspondences are given by the alignment of the shared face. It is useful to know the following information:&lt;linebreak/&gt;
<span class="lineNum">      46 </span>            :  In the Local CNS, if an edge lies along the xi direction, if one takes the two corners making up that edge and takes the difference of their ids, one always gets the result &lt;formula id=&quot;1549&quot;&gt;$ \pm 1$&lt;/formula&gt;. Similarly, if the edge lies in the eta direction, the result will be &lt;formula id=&quot;1550&quot;&gt;$ \pm 2$&lt;/formula&gt;. Finally, if the edge lies in the zeta direction, the result will be &lt;formula id=&quot;1551&quot;&gt;$ \pm 4$&lt;/formula&gt;. We use this information to determine the alignment of the shared face:&lt;/para&gt;&lt;para&gt;&lt;programlisting&gt;&lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;Block1:&lt;sp/&gt;3-1=2&lt;sp/&gt;&lt;sp/&gt;=&amp;gt;&lt;sp/&gt;This&lt;sp/&gt;edge&lt;sp/&gt;is&lt;sp/&gt;in&lt;sp/&gt;the&lt;sp/&gt;+eta&lt;sp/&gt;direction.&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      47 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;Block2:&lt;sp/&gt;1-0=1&lt;sp/&gt;=&amp;gt;&lt;sp/&gt;This&lt;sp/&gt;edge&lt;sp/&gt;is&lt;sp/&gt;in&lt;sp/&gt;the&lt;sp/&gt;+xi&lt;sp/&gt;direction.&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      48 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;Then,&lt;sp/&gt;+eta&lt;sp/&gt;in&lt;sp/&gt;Block1&lt;sp/&gt;corresponds&lt;sp/&gt;to&lt;sp/&gt;+xi&lt;sp/&gt;in&lt;sp/&gt;Block2.&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      49 </span>            : &lt;codeline&gt;&lt;/codeline&gt;
<span class="lineNum">      50 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;Block1:&lt;sp/&gt;5-1=4&lt;sp/&gt;=&amp;gt;&lt;sp/&gt;This&lt;sp/&gt;edge&lt;sp/&gt;is&lt;sp/&gt;in&lt;sp/&gt;the&lt;sp/&gt;+zeta&lt;sp/&gt;direction.&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      51 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;Block2:&lt;sp/&gt;2-0=2&lt;sp/&gt;=&amp;gt;&lt;sp/&gt;This&lt;sp/&gt;edge&lt;sp/&gt;is&lt;sp/&gt;in&lt;sp/&gt;the&lt;sp/&gt;+eta&lt;sp/&gt;direction.&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      52 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;Then,&lt;sp/&gt;+zeta&lt;sp/&gt;in&lt;sp/&gt;Block1&lt;sp/&gt;corresponds&lt;sp/&gt;to&lt;sp/&gt;+eta&lt;sp/&gt;in&lt;sp/&gt;Block2.&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      53 </span>            : &lt;/programlisting&gt;&lt;/para&gt;&lt;para&gt;The corresponding directions in each &lt;ref refid=&quot;classBlock&quot; kindref=&quot;compound&quot;&gt;Block&lt;/ref&gt; have now been deduced.&lt;/para&gt;&lt;para&gt;To confirm, we can use the other ids as well and arrive at the same result:&lt;linebreak/&gt;
<span class="lineNum">      54 </span>            : &lt;/para&gt;&lt;para&gt;&lt;programlisting&gt;&lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;Block1:&lt;sp/&gt;7-5=2&lt;sp/&gt;&lt;sp/&gt;=&amp;gt;&lt;sp/&gt;+eta&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      55 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;Block2:&lt;sp/&gt;3-2=1&lt;sp/&gt;=&amp;gt;&lt;sp/&gt;+xi&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      56 </span>            : &lt;codeline&gt;&lt;/codeline&gt;
<span class="lineNum">      57 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;Block1:&lt;sp/&gt;7-3=4&lt;sp/&gt;&lt;sp/&gt;=&amp;gt;&lt;sp/&gt;+zeta&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      58 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;Block2:&lt;sp/&gt;3-1=2&lt;sp/&gt;&lt;sp/&gt;=&amp;gt;&lt;sp/&gt;+eta&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      59 </span>            : &lt;/programlisting&gt;&lt;/para&gt;&lt;para&gt;&lt;heading level=&quot;3&quot;&gt;Setting Periodic Boundary Conditions&lt;/heading&gt;
<span class="lineNum">      60 </span>            : &lt;/para&gt;&lt;para&gt;It is also possible to identify faces of a &lt;ref refid=&quot;classBlock&quot; kindref=&quot;compound&quot;&gt;Block&lt;/ref&gt; using the subset CNS. For example, to identify the lower zeta face with the upper zeta face of a &lt;ref refid=&quot;classBlock&quot; kindref=&quot;compound&quot;&gt;Block&lt;/ref&gt; where the corners are labeled &lt;computeroutput&gt;{3,0,4,1,9,6,10,7}&lt;/computeroutput&gt;, one may supply the lists &lt;computeroutput&gt;{3,0,4,1}&lt;/computeroutput&gt; and &lt;computeroutput&gt;{9,6,10,7}&lt;/computeroutput&gt; to the &lt;computeroutput&gt;set_identified_boundaries&lt;/computeroutput&gt; function. &lt;simplesect kind=&quot;note&quot;&gt;&lt;para&gt;The &lt;computeroutput&gt;set_identified_boundaries&lt;/computeroutput&gt; function is sensitive to the order of the corners in the lists supplied as arguments. This is because the function identifies corners and edges with each other as opposed to simply faces. This allows the user to specify more peculiar boundary conditions. For example, using &lt;computeroutput&gt;{3,0,4,1}&lt;/computeroutput&gt; and &lt;computeroutput&gt;{6,7,9,10}&lt;/computeroutput&gt; to set the periodic boundaries will identify the lower zeta face with the upper zeta face, but after a rotation of a quarter-turn.&lt;/para&gt;&lt;/simplesect&gt;
<span class="lineNum">      61 </span>            : For reference, here are the corners to use for each face for a &lt;ref refid=&quot;classBlock&quot; kindref=&quot;compound&quot;&gt;Block&lt;/ref&gt; with corners labelled as &lt;computeroutput&gt;{0,1,2,3,4,5,6,7}&lt;/computeroutput&gt; to set up periodic boundary conditions in each dimension, i.e. a &lt;formula id=&quot;1552&quot;&gt;$\mathrm{T}^3$&lt;/formula&gt; topology:&lt;/para&gt;&lt;para&gt;&lt;table rows=&quot;7&quot; cols=&quot;2&quot;&gt;&lt;row&gt;
<span class="lineNum">      62 </span>            : &lt;entry thead=&quot;yes&quot;&gt;&lt;para&gt;Face &lt;/para&gt;&lt;/entry&gt;&lt;entry thead=&quot;yes&quot;&gt;&lt;para&gt;Corners  &lt;/para&gt;&lt;/entry&gt;&lt;/row&gt;
<span class="lineNum">      63 </span>            : &lt;row&gt;
<span class="lineNum">      64 </span>            : &lt;entry thead=&quot;no&quot;&gt;&lt;para&gt;upper xi&lt;/para&gt;&lt;/entry&gt;&lt;entry thead=&quot;no&quot;&gt;&lt;para&gt;&lt;computeroutput&gt;{1,3,5,7}&lt;/computeroutput&gt; &lt;/para&gt;&lt;/entry&gt;&lt;/row&gt;
<span class="lineNum">      65 </span>            : &lt;row&gt;
<span class="lineNum">      66 </span>            : &lt;entry thead=&quot;no&quot;&gt;&lt;para&gt;lower xi&lt;/para&gt;&lt;/entry&gt;&lt;entry thead=&quot;no&quot;&gt;&lt;para&gt;&lt;computeroutput&gt;{0,2,4,6}&lt;/computeroutput&gt; &lt;/para&gt;&lt;/entry&gt;&lt;/row&gt;
<span class="lineNum">      67 </span>            : &lt;row&gt;
<span class="lineNum">      68 </span>            : &lt;entry thead=&quot;no&quot;&gt;&lt;para&gt;upper eta&lt;/para&gt;&lt;/entry&gt;&lt;entry thead=&quot;no&quot;&gt;&lt;para&gt;&lt;computeroutput&gt;{2,3,6,7}&lt;/computeroutput&gt; &lt;/para&gt;&lt;/entry&gt;&lt;/row&gt;
<span class="lineNum">      69 </span>            : &lt;row&gt;
<span class="lineNum">      70 </span>            : &lt;entry thead=&quot;no&quot;&gt;&lt;para&gt;lower eta&lt;/para&gt;&lt;/entry&gt;&lt;entry thead=&quot;no&quot;&gt;&lt;para&gt;&lt;computeroutput&gt;{0,1,4,5}&lt;/computeroutput&gt; &lt;/para&gt;&lt;/entry&gt;&lt;/row&gt;
<span class="lineNum">      71 </span>            : &lt;row&gt;
<span class="lineNum">      72 </span>            : &lt;entry thead=&quot;no&quot;&gt;&lt;para&gt;upper zeta&lt;/para&gt;&lt;/entry&gt;&lt;entry thead=&quot;no&quot;&gt;&lt;para&gt;&lt;computeroutput&gt;{4,5,6,7}&lt;/computeroutput&gt; &lt;/para&gt;&lt;/entry&gt;&lt;/row&gt;
<span class="lineNum">      73 </span>            : &lt;row&gt;
<span class="lineNum">      74 </span>            : &lt;entry thead=&quot;no&quot;&gt;&lt;para&gt;lower zeta&lt;/para&gt;&lt;/entry&gt;&lt;entry thead=&quot;no&quot;&gt;&lt;para&gt;&lt;computeroutput&gt;{0,1,2,3}&lt;/computeroutput&gt; &lt;/para&gt;&lt;/entry&gt;&lt;/row&gt;
<span class="lineNum">      75 </span>            : &lt;/table&gt;
<span class="lineNum">      76 </span>            : &lt;/para&gt;    &lt;/detaileddescription&gt;
<span class="lineNum">      77 </span>            :   &lt;/compounddef&gt;
<span class="lineNum">      78 </span>            : &lt;/doxygen&gt;
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
