<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - b1f4fe8326c5dc9de3d64954e9325e08a2677cfd - /work/build_Debug_clang/docs/xml/implementing_vectors.xml</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title"> SpECTRE Documentation Coverage Report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">work/build_Debug_clang/docs/xml</a> - implementing_vectors.xml</td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
             <td class="headerItem">Commit:</td>
             <td class="headerValue"><a target="_blank" href="https://github.com/sxs-collaboration/spectre/commit/b1f4fe8326c5dc9de3d64954e9325e08a2677cfd">b1f4fe8326c5dc9de3d64954e9325e08a2677cfd</a></td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2019-10-20 17:39:50</td>
            <td></td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<span class="lineNum">       1 </span><span class="lineCov">          1 : &lt;?xml version='1.0' encoding='UTF-8' standalone='no'?&gt;</span>
<span class="lineNum">       2 </span>            : &lt;doxygen xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;compound.xsd&quot; version=&quot;1.8.13&quot;&gt;
<span class="lineNum">       3 </span>            :   &lt;compounddef id=&quot;implementing_vectors&quot; kind=&quot;page&quot;&gt;
<span class="lineNum">       4 </span>            :     &lt;compoundname&gt;implementing_vectors&lt;/compoundname&gt;
<span class="lineNum">       5 </span>            :     &lt;title&gt;Implementing SpECTRE vectors&lt;/title&gt;
<span class="lineNum">       6 </span>            :     &lt;detaileddescription&gt;
<span class="lineNum">       7 </span>            : &lt;sect1 id=&quot;implementing_vectors_1general_structure&quot;&gt;
<span class="lineNum">       8 </span>            : &lt;title&gt;Overview of SpECTRE Vectors&lt;/title&gt;
<span class="lineNum">       9 </span>            : &lt;para&gt;In SpECTRE, sets of contiguous or related data are stored in specializations of vector data types. The canonical implementation of this is the &lt;computeroutput&gt;&lt;ref refid=&quot;classDataVector&quot; kindref=&quot;compound&quot;&gt;DataVector&lt;/ref&gt;&lt;/computeroutput&gt;, which is used for storage of a contiguous sequence of doubles which support a wide variety of mathematical operations and represent data on a grid used during an evolution or elliptic solve. However, we support the ability to easily generate similar vector types which can hold data of a different type (e.g. &lt;computeroutput&gt;&lt;ref refid=&quot;cpp/numeric/complex&quot; kindref=&quot;compound&quot; external=&quot;/work/spectre/docs/config/cppreference-doxygen-web.tag.xml&quot;&gt;std::complex&lt;/ref&gt;&amp;lt;double&amp;gt;&lt;/computeroutput&gt;), or support a different set of mathematical operations. SpECTRE vector classes are derived from the class template &lt;computeroutput&gt;&lt;ref refid=&quot;classVectorImpl&quot; kindref=&quot;compound&quot;&gt;VectorImpl&lt;/ref&gt;&lt;/computeroutput&gt;. The remainder of this brief guide gives a description of the tools for defining additional vector types.&lt;/para&gt;&lt;para&gt;For reference, all functions described here can also be found in brief in the Doxygen documentation for &lt;ref refid=&quot;VectorImpl_8hpp_source&quot; kindref=&quot;compound&quot;&gt;VectorImpl.hpp&lt;/ref&gt;, and a simple reference implementation can be found in &lt;ref refid=&quot;DataVector_8hpp_source&quot; kindref=&quot;compound&quot;&gt;DataVector.hpp&lt;/ref&gt; and DataVector.cpp.&lt;/para&gt;&lt;/sect1&gt;
<span class="lineNum">      10 </span>            : &lt;sect1 id=&quot;implementing_vectors_1class_definition&quot;&gt;
<span class="lineNum">      11 </span>            : &lt;title&gt;The class definition&lt;/title&gt;
<span class="lineNum">      12 </span>            : &lt;para&gt;SpECTRE vector types inherit from vector types implemented in the high-performance arithmetic library &lt;ulink url=&quot;https://bitbucket.org/blaze-lib/blaze&quot;&gt;Blaze&lt;/ulink&gt;. Using inheritance, SpECTRE vectors gracefully make use of the math functions defined for the Blaze types, but can be customized for the specific needs in SpECTRE computations.&lt;/para&gt;&lt;para&gt;The pair of template parameters for &lt;computeroutput&gt;&lt;ref refid=&quot;classVectorImpl&quot; kindref=&quot;compound&quot;&gt;VectorImpl&lt;/ref&gt;&lt;/computeroutput&gt; are the type of the stored data (e.g. &lt;computeroutput&gt;double&lt;/computeroutput&gt; for &lt;computeroutput&gt;&lt;ref refid=&quot;classDataVector&quot; kindref=&quot;compound&quot;&gt;DataVector&lt;/ref&gt;&lt;/computeroutput&gt;), and the result type for mathematical operations. The result type is used by Blaze to ensure that only compatible vector types are used together in mathematical expressions. For example, a vector representing &lt;computeroutput&gt;double&lt;/computeroutput&gt; data on a grid (&lt;computeroutput&gt;&lt;ref refid=&quot;classDataVector&quot; kindref=&quot;compound&quot;&gt;DataVector&lt;/ref&gt;&lt;/computeroutput&gt;) cannot be added to a vector representing spectral coefficients (&lt;computeroutput&gt;&lt;ref refid=&quot;classModalVector&quot; kindref=&quot;compound&quot;&gt;ModalVector&lt;/ref&gt;&lt;/computeroutput&gt;). This avoids subtle bugs that arise when vector types are unintentionally mixed. In nearly all cases the result type will be the vector type that is being defined, so, for instance, &lt;computeroutput&gt;&lt;ref refid=&quot;classDataVector&quot; kindref=&quot;compound&quot;&gt;DataVector&lt;/ref&gt;&lt;/computeroutput&gt; is a derived class of &lt;computeroutput&gt;&lt;ref refid=&quot;classVectorImpl&quot; kindref=&quot;compound&quot;&gt;VectorImpl&lt;/ref&gt;&amp;lt;double, &lt;ref refid=&quot;classDataVector&quot; kindref=&quot;compound&quot;&gt;DataVector&lt;/ref&gt;&amp;gt;&lt;/computeroutput&gt;. This template pattern is known as the &lt;ulink url=&quot;https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern&quot;&gt;&amp;quot;Curiously Recurring Template Pattern&amp;quot;&lt;/ulink&gt; (CRTP).&lt;/para&gt;&lt;para&gt;The class template &lt;computeroutput&gt;&lt;ref refid=&quot;classVectorImpl&quot; kindref=&quot;compound&quot;&gt;VectorImpl&lt;/ref&gt;&lt;/computeroutput&gt; defines various constructors, assignment operators, and iterator generation members. Most of these are inherited from Blaze types, but in addition, the methods &lt;computeroutput&gt;set_data_ref&lt;/computeroutput&gt;, and &lt;computeroutput&gt;pup&lt;/computeroutput&gt; are defined for use in SpECTRE. All except for the assignment operators and constructors will be implicitly inherited from &lt;computeroutput&gt;&lt;ref refid=&quot;classVectorImpl&quot; kindref=&quot;compound&quot;&gt;VectorImpl&lt;/ref&gt;&lt;/computeroutput&gt;. The assignment and constructors may be inherited calling the following alias code in the vector class definition:&lt;/para&gt;&lt;para&gt;&lt;programlisting&gt;&lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;using&lt;sp/&gt;VectorImpl&amp;lt;T,VectorType&amp;gt;::operator=;&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      13 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;using&lt;sp/&gt;VectorImpl&amp;lt;T,VectorType&amp;gt;::VectorImpl;&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      14 </span>            : &lt;/programlisting&gt;&lt;/para&gt;&lt;para&gt;Only the mathematical operations supported on the base Blaze types are supported by default. Those operations are determined by the storage type &lt;computeroutput&gt;T&lt;/computeroutput&gt; and by the Blaze library. See &lt;ulink url=&quot;https://bitbucket.org/blaze-lib/blaze/wiki/Vector%20Operations&quot;&gt;blaze-wiki/Vector_Operations&lt;/ulink&gt;.&lt;/para&gt;&lt;para&gt;Other math operations may be defined either in the class definition or outside. For ease in defining some of these math operations, &lt;computeroutput&gt;&lt;ref refid=&quot;PointerVector_8hpp&quot; kindref=&quot;compound&quot;&gt;PointerVector.hpp&lt;/ref&gt;&lt;/computeroutput&gt; defines the macro &lt;computeroutput&gt;MAKE_EXPRESSION_MATH_ASSIGN(OP, TYPE)&lt;/computeroutput&gt;, which can be used to define math assignment operations such as &lt;computeroutput&gt;+=&lt;/computeroutput&gt; provided the underlying operation (e.g. &lt;computeroutput&gt;+&lt;/computeroutput&gt;) is defined on the Blaze type.&lt;/para&gt;&lt;/sect1&gt;
<span class="lineNum">      15 </span>            : &lt;sect1 id=&quot;implementing_vectors_1blaze_definitions&quot;&gt;
<span class="lineNum">      16 </span>            : &lt;title&gt;Allowed operator specification&lt;/title&gt;
<span class="lineNum">      17 </span>            : &lt;para&gt;Blaze keeps track of the return type of unary and binary operations using &amp;quot;type
<span class="lineNum">      18 </span>            : trait&amp;quot; structs. These specializations for vector types should be placed in the header file associated with the &lt;computeroutput&gt;&lt;ref refid=&quot;classVectorImpl&quot; kindref=&quot;compound&quot;&gt;VectorImpl&lt;/ref&gt;&lt;/computeroutput&gt; specialization. For &lt;computeroutput&gt;&lt;ref refid=&quot;classDataVector&quot; kindref=&quot;compound&quot;&gt;DataVector&lt;/ref&gt;&lt;/computeroutput&gt;, the specializations are defined in &lt;computeroutput&gt;&lt;ref refid=&quot;DataVector_8hpp_source&quot; kindref=&quot;compound&quot;&gt;DataStructures/DataVector.hpp&lt;/ref&gt;&lt;/computeroutput&gt;. The presence or absence of template specializations of these structs also determines the set of allowed operations between the vector type and other types. For example, if adding a &lt;computeroutput&gt;double&lt;/computeroutput&gt; to a &lt;computeroutput&gt;&lt;ref refid=&quot;classDataVector&quot; kindref=&quot;compound&quot;&gt;DataVector&lt;/ref&gt;&lt;/computeroutput&gt; should be allowed and the result should be treated as a &lt;computeroutput&gt;&lt;ref refid=&quot;classDataVector&quot; kindref=&quot;compound&quot;&gt;DataVector&lt;/ref&gt;&lt;/computeroutput&gt; for subsequent operations, then the struct &lt;computeroutput&gt;blaze::AddTrait&amp;lt;&lt;ref refid=&quot;classDataVector&quot; kindref=&quot;compound&quot;&gt;DataVector&lt;/ref&gt;, double&amp;gt;&lt;/computeroutput&gt; needs to be defined as follows:&lt;/para&gt;&lt;para&gt;&lt;programlisting&gt;&lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;namespace&lt;sp/&gt;blaze&lt;sp/&gt;{&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      19 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;//&lt;sp/&gt;the&lt;sp/&gt;`template&lt;sp/&gt;&amp;lt;&amp;gt;`&lt;sp/&gt;head&lt;sp/&gt;tells&lt;sp/&gt;the&lt;sp/&gt;compiler&lt;sp/&gt;that&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      20 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;//&lt;sp/&gt;`AddTrait&amp;lt;DataVector,&lt;sp/&gt;double&amp;gt;`&lt;sp/&gt;is&lt;sp/&gt;a&lt;sp/&gt;class&lt;sp/&gt;template&lt;sp/&gt;specialization&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      21 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;template&lt;sp/&gt;&amp;lt;&amp;gt;&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      22 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;struct&lt;sp/&gt;AddTrait&amp;lt;DataVector,&lt;sp/&gt;double&amp;gt;&lt;sp/&gt;{&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      23 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;//&lt;sp/&gt;the&lt;sp/&gt;`Type`&lt;sp/&gt;alias&lt;sp/&gt;tells&lt;sp/&gt;blaze&lt;sp/&gt;that&lt;sp/&gt;the&lt;sp/&gt;result&lt;sp/&gt;should&lt;sp/&gt;be&lt;sp/&gt;treated&lt;sp/&gt;like&lt;sp/&gt;a&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      24 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;//&lt;sp/&gt;`DataVector`&lt;sp/&gt;for&lt;sp/&gt;any&lt;sp/&gt;further&lt;sp/&gt;operations&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      25 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;using&lt;sp/&gt;Type&lt;sp/&gt;=&lt;sp/&gt;DataVector;&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      26 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;};&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      27 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;}&lt;sp/&gt;&lt;sp/&gt;//&lt;sp/&gt;namespace&lt;sp/&gt;blaze&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      28 </span>            : &lt;/programlisting&gt;&lt;/para&gt;&lt;para&gt;Note that this only adds support for &lt;computeroutput&gt;&lt;ref refid=&quot;classDataVector&quot; kindref=&quot;compound&quot;&gt;DataVector&lt;/ref&gt; + double&lt;/computeroutput&gt;, not &lt;computeroutput&gt;double + &lt;ref refid=&quot;classDataVector&quot; kindref=&quot;compound&quot;&gt;DataVector&lt;/ref&gt;&lt;/computeroutput&gt;. To get the latter the following AddTrait specialization must be defined&lt;/para&gt;&lt;para&gt;&lt;programlisting&gt;&lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;namespace&lt;sp/&gt;blaze&lt;sp/&gt;{&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      29 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;//&lt;sp/&gt;the&lt;sp/&gt;`template&lt;sp/&gt;&amp;lt;&amp;gt;`&lt;sp/&gt;head&lt;sp/&gt;tells&lt;sp/&gt;the&lt;sp/&gt;compiler&lt;sp/&gt;that&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      30 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;//&lt;sp/&gt;`AddTrait&amp;lt;double,&lt;sp/&gt;DataVector&amp;gt;`&lt;sp/&gt;is&lt;sp/&gt;a&lt;sp/&gt;class&lt;sp/&gt;template&lt;sp/&gt;specialization&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      31 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;template&lt;sp/&gt;&amp;lt;&amp;gt;&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      32 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;struct&lt;sp/&gt;AddTrait&amp;lt;double,&lt;sp/&gt;DataVector&amp;gt;&lt;sp/&gt;{&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      33 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;//&lt;sp/&gt;the&lt;sp/&gt;`Type`&lt;sp/&gt;alias&lt;sp/&gt;tells&lt;sp/&gt;blaze&lt;sp/&gt;that&lt;sp/&gt;the&lt;sp/&gt;result&lt;sp/&gt;should&lt;sp/&gt;be&lt;sp/&gt;treated&lt;sp/&gt;like&lt;sp/&gt;a&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      34 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;//&lt;sp/&gt;`DataVector`&lt;sp/&gt;for&lt;sp/&gt;any&lt;sp/&gt;further&lt;sp/&gt;operations&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      35 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;using&lt;sp/&gt;Type&lt;sp/&gt;=&lt;sp/&gt;DataVector;&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      36 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;};&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      37 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;}&lt;sp/&gt;&lt;sp/&gt;//&lt;sp/&gt;namespace&lt;sp/&gt;blaze&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      38 </span>            : &lt;/programlisting&gt;&lt;/para&gt;&lt;para&gt;Four helper macros are defined to assist with generating the many specializations that binary operations may require. Both of these macros must be put inside the blaze namespace for them to work correctly.&lt;/para&gt;&lt;para&gt;The first of these helper macros is &lt;computeroutput&gt;&lt;ref refid=&quot;group__DataStructuresGroup_1gafecda8db57d55c644d6cf13c9321883c&quot; kindref=&quot;member&quot;&gt;BLAZE_TRAIT_SPECIALIZE_BINARY_TRAIT(VECTOR_TYPE, BLAZE_MATH_TRAIT)&lt;/ref&gt;&lt;/computeroutput&gt;, which will define all of the pairwise operations (&lt;computeroutput&gt;BLAZE_MATH_TRAIT&lt;/computeroutput&gt;) for the vector type (&lt;computeroutput&gt;VECTOR_TYPE&lt;/computeroutput&gt;) with itself and for the vector type with its &lt;computeroutput&gt;value_type&lt;/computeroutput&gt;. This reduces the three specializations similar to the above code blocks to a single line call,&lt;/para&gt;&lt;para&gt;&lt;programlisting&gt;&lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;namespace&lt;sp/&gt;blaze&lt;sp/&gt;{&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      39 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;BLAZE_TRAIT_SPECIALIZE_BINARY_TRAIT(DataVector,&lt;sp/&gt;AddTrait)&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      40 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;}&lt;sp/&gt;&lt;sp/&gt;//&lt;sp/&gt;namespace&lt;sp/&gt;blaze&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      41 </span>            : &lt;/programlisting&gt;&lt;/para&gt;&lt;para&gt;The second helper macro is provided to easily define all of the arithmetic operations that will typically be supported for a vector type with its value type. The macro is &lt;computeroutput&gt;&lt;ref refid=&quot;group__DataStructuresGroup_1gac6e23b3575c630977f52a42c99af6aec&quot; kindref=&quot;member&quot;&gt;VECTOR_BLAZE_TRAIT_SPECIALIZE_ARITHMETIC_TRAITS(VECTOR_TYPE)&lt;/ref&gt;&lt;/computeroutput&gt;, and defines all of:&lt;itemizedlist&gt;
<span class="lineNum">      42 </span>            : &lt;listitem&gt;&lt;para&gt;&lt;computeroutput&gt;IsVector&amp;lt;VECTOR_TYPE&amp;gt;&lt;/computeroutput&gt; to &lt;computeroutput&gt;&lt;ref refid=&quot;cpp/types/integral_constant&quot; kindref=&quot;compound&quot; external=&quot;/work/spectre/docs/config/cppreference-doxygen-web.tag.xml&quot;&gt;std::true_type&lt;/ref&gt;&lt;/computeroutput&gt;&lt;/para&gt;&lt;/listitem&gt;&lt;listitem&gt;&lt;para&gt;&lt;computeroutput&gt;TransposeFlag&amp;lt;VECTOR_TYPE&amp;gt;&lt;/computeroutput&gt;, which informs Blaze of the interpretation of the data as a &amp;quot;column&amp;quot; or &amp;quot;row&amp;quot; vector&lt;/para&gt;&lt;/listitem&gt;&lt;listitem&gt;&lt;para&gt;&lt;computeroutput&gt;AddTrait&lt;/computeroutput&gt; for the &lt;computeroutput&gt;VECTOR_TYPE&lt;/computeroutput&gt; and its value type (3 Blaze struct specializations)&lt;/para&gt;&lt;/listitem&gt;&lt;listitem&gt;&lt;para&gt;&lt;computeroutput&gt;SubTrait&lt;/computeroutput&gt; for the &lt;computeroutput&gt;VECTOR_TYPE&lt;/computeroutput&gt; and its value type (3 Blaze struct specializations)&lt;/para&gt;&lt;/listitem&gt;&lt;listitem&gt;&lt;para&gt;&lt;computeroutput&gt;MultTrait&lt;/computeroutput&gt; for the &lt;computeroutput&gt;VECTOR_TYPE&lt;/computeroutput&gt; and its value type (3 Blaze struct specializations)&lt;/para&gt;&lt;/listitem&gt;&lt;listitem&gt;&lt;para&gt;&lt;computeroutput&gt;DivTrait&lt;/computeroutput&gt; for the &lt;computeroutput&gt;VECTOR_TYPE&lt;/computeroutput&gt; and its value type (3 Blaze struct specializations)&lt;/para&gt;&lt;/listitem&gt;&lt;/itemizedlist&gt;
<span class="lineNum">      43 </span>            : &lt;/para&gt;&lt;para&gt;This macro is similarly intended to be used in the &lt;computeroutput&gt;blaze&lt;/computeroutput&gt; namespace and can substantially simplify these specializations for new vector types. For instance, the call for &lt;computeroutput&gt;&lt;ref refid=&quot;classDataVector&quot; kindref=&quot;compound&quot;&gt;DataVector&lt;/ref&gt;&lt;/computeroutput&gt; is:&lt;/para&gt;&lt;para&gt;&lt;programlisting&gt;&lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;namespace&lt;sp/&gt;blaze&lt;sp/&gt;{&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      44 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;VECTOR_BLAZE_TRAIT_SPECIALIZE_ARITHMETIC_TRAITS(DataVector)&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      45 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;}&lt;sp/&gt;&lt;sp/&gt;//&lt;sp/&gt;namespace&lt;sp/&gt;blaze&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      46 </span>            : &lt;/programlisting&gt;&lt;/para&gt;&lt;para&gt;The third helper macro is provided to define a combination of Blaze traits for symmetric operations of a vector type with a second type (which may or may not be a vector type). The macro is &lt;computeroutput&gt;&lt;ref refid=&quot;group__DataStructuresGroup_1gad678231c651cb6e4e6b428467c860f0d&quot; kindref=&quot;member&quot;&gt;BLAZE_TRAIT_SPECIALIZE_COMPATIBLE_BINARY_TRAIT(VECTOR, COMPATIBLE, TRAIT)&lt;/ref&gt;&lt;/computeroutput&gt;, and defines the appropriate trait for the two combinations &lt;computeroutput&gt;&amp;lt;VECTOR, COMPATIBLE&amp;gt;&lt;/computeroutput&gt; and &lt;computeroutput&gt;&amp;lt;COMPATIBLE, VECTOR&amp;gt;&lt;/computeroutput&gt;, and defines the result type to be &lt;computeroutput&gt;VECTOR&lt;/computeroutput&gt;. For instance, to support the multiplication of a &lt;computeroutput&gt;&lt;ref refid=&quot;classComplexDataVector&quot; kindref=&quot;compound&quot;&gt;ComplexDataVector&lt;/ref&gt;&lt;/computeroutput&gt; with a &lt;computeroutput&gt;&lt;ref refid=&quot;classDataVector&quot; kindref=&quot;compound&quot;&gt;DataVector&lt;/ref&gt;&lt;/computeroutput&gt; and have the result be a &lt;computeroutput&gt;&lt;ref refid=&quot;classComplexDataVector&quot; kindref=&quot;compound&quot;&gt;ComplexDataVector&lt;/ref&gt;&lt;/computeroutput&gt;, the following macro call should be included in the &lt;computeroutput&gt;blaze&lt;/computeroutput&gt; namespace:&lt;/para&gt;&lt;para&gt;&lt;programlisting&gt;&lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;namespace&lt;sp/&gt;blaze&lt;sp/&gt;{&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      47 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;BLAZE_TRAIT_SPECIALIZE_COMPATIBLE_BINARY_TRAIT(ComplexDataVector,&lt;sp/&gt;DataVector,&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      48 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;MultTrait);&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      49 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;}&lt;sp/&gt;&lt;sp/&gt;//&lt;sp/&gt;namespace&lt;sp/&gt;blaze&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      50 </span>            : &lt;/programlisting&gt;&lt;/para&gt;&lt;para&gt;Finally, the fourth helper macro is provided to define all of the blaze traits which are considered either unary or binary maps. This comprises most named unary functions (like &lt;computeroutput&gt;sin()&lt;/computeroutput&gt; or &lt;computeroutput&gt;sqrt()&lt;/computeroutput&gt;) and named binary functions (like &lt;computeroutput&gt;hypot()&lt;/computeroutput&gt; and &lt;computeroutput&gt;atan2()&lt;/computeroutput&gt;). The macro &lt;computeroutput&gt;&lt;ref refid=&quot;group__DataStructuresGroup_1ga7174934f57eac4f19e94aaabbcf4f5fc&quot; kindref=&quot;member&quot;&gt;VECTOR_BLAZE_TRAIT_SPECIALIZE_ALL_MAP_TRAITS(VECTOR_TYPE)&lt;/ref&gt;&lt;/computeroutput&gt; broadly specializes all blaze-defined maps in which the given &lt;computeroutput&gt;VECTOR_TYPE&lt;/computeroutput&gt; as the sole argument (for unary maps) or both arguments (for binary maps). This macro is also intended to be used in the blaze namespace. The call for &lt;computeroutput&gt;&lt;ref refid=&quot;classDataVector&quot; kindref=&quot;compound&quot;&gt;DataVector&lt;/ref&gt;&lt;/computeroutput&gt; is:&lt;/para&gt;&lt;para&gt;&lt;programlisting&gt;&lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;namespace&lt;sp/&gt;blaze&lt;sp/&gt;{&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      51 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;VECTOR_BLAZE_TRAIT_SPECIALIZE_ALL_MAP_TRAITS(DataVector)&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      52 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;}&lt;sp/&gt;&lt;sp/&gt;//&lt;sp/&gt;namespace&lt;sp/&gt;blaze&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      53 </span>            : &lt;/programlisting&gt;&lt;/para&gt;&lt;/sect1&gt;
<span class="lineNum">      54 </span>            : &lt;sect1 id=&quot;implementing_vectors_1array_vector_definitions&quot;&gt;
<span class="lineNum">      55 </span>            : &lt;title&gt;Supporting operations for `std::array`s of vectors&lt;/title&gt;
<span class="lineNum">      56 </span>            : &lt;para&gt;In addition to operations between SpECTRE vectors, it is useful to gracefully handle operations between &lt;computeroutput&gt;std::arrays&lt;/computeroutput&gt; of vectors element-wise. There are general macros defined for handling operations between array specializations: &lt;computeroutput&gt;DEFINE_STD_ARRAY_BINOP&lt;/computeroutput&gt; and &lt;computeroutput&gt;DEFINE_STD_ARRAY_INPLACE_BINOP&lt;/computeroutput&gt; from &lt;computeroutput&gt;&lt;ref refid=&quot;StdArrayHelpers_8hpp&quot; kindref=&quot;compound&quot;&gt;Utilities/StdArrayHelpers.hpp&lt;/ref&gt;&lt;/computeroutput&gt;.&lt;/para&gt;&lt;para&gt;In addition, there is a macro for rapidly generating addition and subtraction between arrays of vectors and arrays of their data types. The macro &lt;computeroutput&gt;&lt;ref refid=&quot;group__DataStructuresGroup_1ga05d20a8d7699c607544de057dcb975ee&quot; kindref=&quot;member&quot;&gt;MAKE_STD_ARRAY_VECTOR_BINOPS(VECTOR_TYPE)&lt;/ref&gt;&lt;/computeroutput&gt; will define:&lt;itemizedlist&gt;
<span class="lineNum">      57 </span>            : &lt;listitem&gt;&lt;para&gt;the element-wise &lt;computeroutput&gt;+&lt;/computeroutput&gt; and &lt;computeroutput&gt;-&lt;/computeroutput&gt; with &lt;computeroutput&gt;&lt;ref refid=&quot;cpp/container/array&quot; kindref=&quot;compound&quot; external=&quot;/work/spectre/docs/config/cppreference-doxygen-web.tag.xml&quot;&gt;std::array&lt;/ref&gt;&amp;lt;VECTOR_TYPE, N&amp;gt;&lt;/computeroutput&gt; and &lt;computeroutput&gt;&lt;ref refid=&quot;cpp/container/array&quot; kindref=&quot;compound&quot; external=&quot;/work/spectre/docs/config/cppreference-doxygen-web.tag.xml&quot;&gt;std::array&lt;/ref&gt;&amp;lt;VECTOR_TYPE, N&amp;gt;&lt;/computeroutput&gt;&lt;/para&gt;&lt;/listitem&gt;&lt;listitem&gt;&lt;para&gt;the element-wise &lt;computeroutput&gt;+&lt;/computeroutput&gt; and &lt;computeroutput&gt;-&lt;/computeroutput&gt; of either ordering of &lt;computeroutput&gt;&lt;ref refid=&quot;cpp/container/array&quot; kindref=&quot;compound&quot; external=&quot;/work/spectre/docs/config/cppreference-doxygen-web.tag.xml&quot;&gt;std::array&lt;/ref&gt;&amp;lt;VECTOR_TYPE, N&amp;gt;&lt;/computeroutput&gt; with &lt;computeroutput&gt;&lt;ref refid=&quot;cpp/container/array&quot; kindref=&quot;compound&quot; external=&quot;/work/spectre/docs/config/cppreference-doxygen-web.tag.xml&quot;&gt;std::array&lt;/ref&gt;&amp;lt;VECTOR_TYPE::value_type, N&amp;gt;&lt;/computeroutput&gt;&lt;/para&gt;&lt;/listitem&gt;&lt;listitem&gt;&lt;para&gt;the &lt;computeroutput&gt;+=&lt;/computeroutput&gt; and &lt;computeroutput&gt;-=&lt;/computeroutput&gt; of &lt;computeroutput&gt;&lt;ref refid=&quot;cpp/container/array&quot; kindref=&quot;compound&quot; external=&quot;/work/spectre/docs/config/cppreference-doxygen-web.tag.xml&quot;&gt;std::array&lt;/ref&gt;&amp;lt;VECTOR_TYPE, N&amp;gt;&lt;/computeroutput&gt; with a &lt;computeroutput&gt;&lt;ref refid=&quot;cpp/container/array&quot; kindref=&quot;compound&quot; external=&quot;/work/spectre/docs/config/cppreference-doxygen-web.tag.xml&quot;&gt;std::array&lt;/ref&gt;&amp;lt;VECTOR_TYPE, N&amp;gt;&lt;/computeroutput&gt;&lt;/para&gt;&lt;/listitem&gt;&lt;listitem&gt;&lt;para&gt;the &lt;computeroutput&gt;+=&lt;/computeroutput&gt; and &lt;computeroutput&gt;-=&lt;/computeroutput&gt; of &lt;computeroutput&gt;&lt;ref refid=&quot;cpp/container/array&quot; kindref=&quot;compound&quot; external=&quot;/work/spectre/docs/config/cppreference-doxygen-web.tag.xml&quot;&gt;std::array&lt;/ref&gt;&amp;lt;VECTOR_TYPE, N&amp;gt;&lt;/computeroutput&gt; with a &lt;computeroutput&gt;&lt;ref refid=&quot;cpp/container/array&quot; kindref=&quot;compound&quot; external=&quot;/work/spectre/docs/config/cppreference-doxygen-web.tag.xml&quot;&gt;std::array&lt;/ref&gt;&amp;lt;VECTOR_TYPE::value_type, N&amp;gt;&lt;/computeroutput&gt;.&lt;/para&gt;&lt;/listitem&gt;&lt;/itemizedlist&gt;
<span class="lineNum">      58 </span>            : &lt;/para&gt;&lt;/sect1&gt;
<span class="lineNum">      59 </span>            : &lt;sect1 id=&quot;implementing_vectors_1Vector_type_equivalence&quot;&gt;
<span class="lineNum">      60 </span>            : &lt;title&gt;Equivalence operators&lt;/title&gt;
<span class="lineNum">      61 </span>            : &lt;para&gt;Equivalence operators are supported by the Blaze type inheritance. The equivalence operator &lt;computeroutput&gt;==&lt;/computeroutput&gt; evaluates to true on a pair of vectors if they are the same size and contain the same values, regardless of ownership.&lt;/para&gt;&lt;/sect1&gt;
<span class="lineNum">      62 </span>            : &lt;sect1 id=&quot;implementing_vectors_1Vector_MakeWithValueImpl&quot;&gt;
<span class="lineNum">      63 </span>            : &lt;title&gt;MakeWithValueImpl&lt;/title&gt;
<span class="lineNum">      64 </span>            : &lt;para&gt;SpECTRE offers the convenience function &lt;computeroutput&gt;make_with_value&lt;/computeroutput&gt; for various types. The typical behavior for a SpECTRE vector type is to create a new vector type of the same type and length initialized with the value provided as the second argument in all entries. This behavior may be created by placing the macro &lt;computeroutput&gt;&lt;ref refid=&quot;group__DataStructuresGroup_1gabe9b48242b12719bc435709531049d47&quot; kindref=&quot;member&quot;&gt;MAKE_WITH_VALUE_IMPL_DEFINITION_FOR(VECTOR_TYPE)&lt;/ref&gt;&lt;/computeroutput&gt; in the .hpp file. Any other specializations of &lt;computeroutput&gt;MakeWithValueImpl&lt;/computeroutput&gt; will need to be written manually.&lt;/para&gt;&lt;/sect1&gt;
<span class="lineNum">      65 </span>            : &lt;sect1 id=&quot;implementing_vectors_1Vector_tensor_and_variables&quot;&gt;
<span class="lineNum">      66 </span>            : &lt;title&gt;Interoperability with other data types&lt;/title&gt;
<span class="lineNum">      67 </span>            : &lt;para&gt;When additional vector types are added, small changes are necessary if they are to be used as the base container type either for &lt;computeroutput&gt;Tensor&lt;/computeroutput&gt;s or for &lt;computeroutput&gt;Variables&lt;/computeroutput&gt; (a &lt;computeroutput&gt;Variables&lt;/computeroutput&gt; contains &lt;computeroutput&gt;Tensor&lt;/computeroutput&gt;s), which contain some vector type.&lt;/para&gt;&lt;para&gt;In &lt;computeroutput&gt;&lt;ref refid=&quot;Tensor_8hpp&quot; kindref=&quot;compound&quot;&gt;Tensor.hpp&lt;/ref&gt;&lt;/computeroutput&gt;, there is a &lt;computeroutput&gt;static_assert&lt;/computeroutput&gt; which white-lists the possible types that can be used as the storage type in &lt;computeroutput&gt;Tensor&lt;/computeroutput&gt;s. Any new vectors must be added to that white-list if they are to be used within &lt;computeroutput&gt;Tensor&lt;/computeroutput&gt;s.&lt;/para&gt;&lt;para&gt;&lt;computeroutput&gt;Variables&lt;/computeroutput&gt; is templated on the storage type of the stored &lt;computeroutput&gt;Tensor&lt;/computeroutput&gt;s. However, any new data type should be appropriately tested. New vector types should be tested by invoking new versions of existing testing functions templated on the new vector type, rather than &lt;computeroutput&gt;&lt;ref refid=&quot;classDataVector&quot; kindref=&quot;compound&quot;&gt;DataVector&lt;/ref&gt;&lt;/computeroutput&gt;.&lt;/para&gt;&lt;/sect1&gt;
<span class="lineNum">      68 </span>            : &lt;sect1 id=&quot;implementing_vectors_1Vector_tests&quot;&gt;
<span class="lineNum">      69 </span>            : &lt;title&gt;Writing tests&lt;/title&gt;
<span class="lineNum">      70 </span>            : &lt;para&gt;In addition to the utilities for generating new vector types, there are a number of convenience functions and utilities for easily generating the tests necessary to verify that the vectors function appropriately. These utilities are in &lt;computeroutput&gt;&lt;ref refid=&quot;VectorImplTestHelper_8hpp_source&quot; kindref=&quot;compound&quot;&gt;VectorImplTestHelper.hpp&lt;/ref&gt;&lt;/computeroutput&gt;, and documented individually in the TestingFrameworkGroup. Presented here are the salient details for rapidly assembling basic tests for vectors.&lt;/para&gt;&lt;para&gt;&lt;heading level=&quot;2&quot;&gt;Utility check functions&lt;/heading&gt;
<span class="lineNum">      71 </span>            : &lt;/para&gt;&lt;para&gt;Each of these functions is intended to encapsulate a single frequently used unit test and is templated (in order) on the vector type and the value type to be generated. The default behavior is to uniformly sample values between -100 and 100, but alternative bounds may be passed in via the function arguments.&lt;/para&gt;&lt;para&gt;&lt;heading level=&quot;3&quot;&gt;&lt;computeroutput&gt;&lt;ref refid=&quot;group__TestingFrameworkGroup_1ga8a1befa0bb8af437c081a992f7dc11e8&quot; kindref=&quot;member&quot;&gt;TestHelpers::VectorImpl::vector_test_construct_and_assign()&lt;/ref&gt;&lt;/computeroutput&gt;&lt;/heading&gt;
<span class="lineNum">      72 </span>            : &lt;/para&gt;&lt;para&gt;This function tests a battery of construction and assignment operators for the vector type.&lt;/para&gt;&lt;para&gt;&lt;heading level=&quot;3&quot;&gt;&lt;computeroutput&gt;&lt;ref refid=&quot;group__TestingFrameworkGroup_1ga1107a6a611543b70cc5f895b835a367e&quot; kindref=&quot;member&quot;&gt;TestHelpers::VectorImpl::vector_test_serialize()&lt;/ref&gt;&lt;/computeroutput&gt;&lt;/heading&gt;
<span class="lineNum">      73 </span>            : &lt;/para&gt;&lt;para&gt;This function tests that vector types can be serialized and deserialized, retaining their data.&lt;/para&gt;&lt;para&gt;&lt;heading level=&quot;3&quot;&gt;&lt;computeroutput&gt;&lt;ref refid=&quot;group__TestingFrameworkGroup_1ga2b21aa8a8ec3ed4756193ec01a04d105&quot; kindref=&quot;member&quot;&gt;TestHelpers::VectorImpl::vector_test_ref()&lt;/ref&gt;&lt;/computeroutput&gt;&lt;/heading&gt;
<span class="lineNum">      74 </span>            : &lt;/para&gt;&lt;para&gt;This function tests the &lt;computeroutput&gt;set_data_ref&lt;/computeroutput&gt; method of sharing data between vectors, and that the appropriate owning flags and move operations are handled correctly.&lt;/para&gt;&lt;para&gt;&lt;heading level=&quot;3&quot;&gt;&lt;computeroutput&gt;&lt;ref refid=&quot;group__TestingFrameworkGroup_1ga1c92dd364b5c10deb51c67a29b1f0749&quot; kindref=&quot;member&quot;&gt;TestHelpers::VectorImpl::vector_test_math_after_move()&lt;/ref&gt;&lt;/computeroutput&gt;&lt;/heading&gt;
<span class="lineNum">      75 </span>            : &lt;/para&gt;&lt;para&gt;Tests several combinations of math operations and ownership before and after use of &lt;computeroutput&gt;std::move&lt;/computeroutput&gt;.&lt;/para&gt;&lt;para&gt;&lt;heading level=&quot;3&quot;&gt;&lt;computeroutput&gt;&lt;ref refid=&quot;group__TestingFrameworkGroup_1gabc8106fbcf642235c3a21b28835e8041&quot; kindref=&quot;member&quot;&gt;TestHelpers::VectorImpl::vector_ref_test_size_error()&lt;/ref&gt;&lt;/computeroutput&gt;&lt;/heading&gt;
<span class="lineNum">      76 </span>            : &lt;/para&gt;&lt;para&gt;This function intentionally generates an error when assigning values from one vector to a differently sized, non-owning vector (made non-owning by use of &lt;computeroutput&gt;set_data_ref&lt;/computeroutput&gt;). The assertion test which calls this function should search for the string &amp;quot;Must copy into same size&amp;quot;. Three forms of the test are provided, which are switched between using a value from the enum &lt;computeroutput&gt;RefSizeErrorTestKind&lt;/computeroutput&gt; in the first function argument:&lt;itemizedlist&gt;
<span class="lineNum">      77 </span>            : &lt;listitem&gt;&lt;para&gt;&lt;computeroutput&gt;RefSizeErrorTestKind::Copy&lt;/computeroutput&gt;: tests that the size error is appropriately generated when copying to a non-owning vector of the wrong size.&lt;/para&gt;&lt;/listitem&gt;&lt;listitem&gt;&lt;para&gt;&lt;computeroutput&gt;RefSizeErrorTestKind::ExpressionAssign&lt;/computeroutput&gt;: tests that the size error is appropriately generated when assigning the result of a mathematical expression to a non-owning vector of the wrong size.&lt;/para&gt;&lt;/listitem&gt;&lt;listitem&gt;&lt;para&gt;&lt;computeroutput&gt;RefSizeErrorTestKind::Move&lt;/computeroutput&gt;: tests that the size error is appropriately generated when a vector is &lt;computeroutput&gt;std::move&lt;/computeroutput&gt;d into a non-owning vector of the wrong size&lt;/para&gt;&lt;/listitem&gt;&lt;/itemizedlist&gt;
<span class="lineNum">      78 </span>            : &lt;/para&gt;&lt;para&gt;&lt;heading level=&quot;2&quot;&gt;&lt;computeroutput&gt;&lt;ref refid=&quot;group__TestingFrameworkGroup_1ga990527392f1401e09d2d9799b1a663a7&quot; kindref=&quot;member&quot;&gt;TestHelpers::VectorImpl::test_functions_with_vector_arguments()&lt;/ref&gt;&lt;/computeroutput&gt;&lt;/heading&gt;
<span class="lineNum">      79 </span>            : &lt;/para&gt;&lt;para&gt;This is a general function for testing the mathematical operation of vector types with other vector types and/or their base types, with or without various reference wrappers. This may be used to efficiently test the full set of permitted math operations on a vector. See the documentation of &lt;computeroutput&gt;&lt;ref refid=&quot;group__TestingFrameworkGroup_1ga990527392f1401e09d2d9799b1a663a7&quot; kindref=&quot;member&quot;&gt;test_functions_with_vector_arguments()&lt;/ref&gt;&lt;/computeroutput&gt; for full usage details.&lt;/para&gt;&lt;para&gt;An example simple use case for the math test utility: &lt;programlisting&gt;&lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;/highlight&gt;&lt;highlight class=&quot;keyword&quot;&gt;const&lt;/highlight&gt;&lt;highlight class=&quot;normal&quot;&gt;&lt;sp/&gt;&lt;ref refid=&quot;cpp/container/array&quot; kindref=&quot;compound&quot; external=&quot;/work/spectre/docs/config/cppreference-doxygen-web.tag.xml&quot;&gt;TestHelpers::VectorImpl::Bound&lt;/ref&gt;&lt;sp/&gt;&lt;/highlight&gt;&lt;highlight class=&quot;keyword&quot;&gt;generic&lt;/highlight&gt;&lt;highlight class=&quot;normal&quot;&gt;{{-100.0,&lt;sp/&gt;100.0}};&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      80 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;/highlight&gt;&lt;highlight class=&quot;keyword&quot;&gt;const&lt;/highlight&gt;&lt;highlight class=&quot;normal&quot;&gt;&lt;sp/&gt;&lt;ref refid=&quot;cpp/container/array&quot; kindref=&quot;compound&quot; external=&quot;/work/spectre/docs/config/cppreference-doxygen-web.tag.xml&quot;&gt;TestHelpers::VectorImpl::Bound&lt;/ref&gt;&lt;sp/&gt;mone_one{{-1.0,&lt;sp/&gt;1.0}};&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      81 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;/highlight&gt;&lt;highlight class=&quot;keyword&quot;&gt;const&lt;/highlight&gt;&lt;highlight class=&quot;normal&quot;&gt;&lt;sp/&gt;&lt;ref refid=&quot;cpp/container/array&quot; kindref=&quot;compound&quot; external=&quot;/work/spectre/docs/config/cppreference-doxygen-web.tag.xml&quot;&gt;TestHelpers::VectorImpl::Bound&lt;/ref&gt;&lt;sp/&gt;gt_one{{1.0,&lt;sp/&gt;100.0}};&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      82 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;/highlight&gt;&lt;highlight class=&quot;keyword&quot;&gt;const&lt;/highlight&gt;&lt;highlight class=&quot;normal&quot;&gt;&lt;sp/&gt;&lt;ref refid=&quot;cpp/container/array&quot; kindref=&quot;compound&quot; external=&quot;/work/spectre/docs/config/cppreference-doxygen-web.tag.xml&quot;&gt;TestHelpers::VectorImpl::Bound&lt;/ref&gt;&lt;sp/&gt;positive{{0.01,&lt;sp/&gt;100.0}};&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      83 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;/highlight&gt;&lt;highlight class=&quot;keyword&quot;&gt;const&lt;/highlight&gt;&lt;highlight class=&quot;normal&quot;&gt;&lt;sp/&gt;&lt;/highlight&gt;&lt;highlight class=&quot;keyword&quot;&gt;auto&lt;/highlight&gt;&lt;highlight class=&quot;normal&quot;&gt;&lt;sp/&gt;unary_ops&lt;sp/&gt;=&lt;sp/&gt;std::make_tuple(&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      84 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;std::make_tuple(&lt;ref refid=&quot;structfuncl_1_1Abs&quot; kindref=&quot;compound&quot;&gt;funcl::Abs&amp;lt;&amp;gt;&lt;/ref&gt;{},&lt;sp/&gt;std::make_tuple(&lt;/highlight&gt;&lt;highlight class=&quot;keyword&quot;&gt;generic&lt;/highlight&gt;&lt;highlight class=&quot;normal&quot;&gt;)),&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      85 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;std::make_tuple(&lt;ref refid=&quot;structfuncl_1_1Acos&quot; kindref=&quot;compound&quot;&gt;funcl::Acos&amp;lt;&amp;gt;&lt;/ref&gt;{},&lt;sp/&gt;std::make_tuple(mone_one)),&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      86 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;std::make_tuple(&lt;ref refid=&quot;structfuncl_1_1Acosh&quot; kindref=&quot;compound&quot;&gt;funcl::Acosh&amp;lt;&amp;gt;&lt;/ref&gt;{},&lt;sp/&gt;std::make_tuple(gt_one)),&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      87 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;std::make_tuple(&lt;ref refid=&quot;structfuncl_1_1Asin&quot; kindref=&quot;compound&quot;&gt;funcl::Asin&amp;lt;&amp;gt;&lt;/ref&gt;{},&lt;sp/&gt;std::make_tuple(mone_one)),&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      88 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;std::make_tuple(&lt;ref refid=&quot;structfuncl_1_1Asinh&quot; kindref=&quot;compound&quot;&gt;funcl::Asinh&amp;lt;&amp;gt;&lt;/ref&gt;{},&lt;sp/&gt;std::make_tuple(&lt;/highlight&gt;&lt;highlight class=&quot;keyword&quot;&gt;generic&lt;/highlight&gt;&lt;highlight class=&quot;normal&quot;&gt;)),&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      89 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;std::make_tuple(&lt;ref refid=&quot;structfuncl_1_1Atan&quot; kindref=&quot;compound&quot;&gt;funcl::Atan&amp;lt;&amp;gt;&lt;/ref&gt;{},&lt;sp/&gt;std::make_tuple(&lt;/highlight&gt;&lt;highlight class=&quot;keyword&quot;&gt;generic&lt;/highlight&gt;&lt;highlight class=&quot;normal&quot;&gt;)),&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      90 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;std::make_tuple(&lt;ref refid=&quot;structfuncl_1_1Atanh&quot; kindref=&quot;compound&quot;&gt;funcl::Atanh&amp;lt;&amp;gt;&lt;/ref&gt;{},&lt;sp/&gt;std::make_tuple(mone_one)),&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      91 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;std::make_tuple(&lt;ref refid=&quot;structfuncl_1_1Cbrt&quot; kindref=&quot;compound&quot;&gt;funcl::Cbrt&amp;lt;&amp;gt;&lt;/ref&gt;{},&lt;sp/&gt;std::make_tuple(&lt;/highlight&gt;&lt;highlight class=&quot;keyword&quot;&gt;generic&lt;/highlight&gt;&lt;highlight class=&quot;normal&quot;&gt;)),&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      92 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;std::make_tuple(&lt;ref refid=&quot;structfuncl_1_1Cos&quot; kindref=&quot;compound&quot;&gt;funcl::Cos&amp;lt;&amp;gt;&lt;/ref&gt;{},&lt;sp/&gt;std::make_tuple(&lt;/highlight&gt;&lt;highlight class=&quot;keyword&quot;&gt;generic&lt;/highlight&gt;&lt;highlight class=&quot;normal&quot;&gt;)),&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      93 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;std::make_tuple(&lt;ref refid=&quot;structfuncl_1_1Cosh&quot; kindref=&quot;compound&quot;&gt;funcl::Cosh&amp;lt;&amp;gt;&lt;/ref&gt;{},&lt;sp/&gt;std::make_tuple(&lt;/highlight&gt;&lt;highlight class=&quot;keyword&quot;&gt;generic&lt;/highlight&gt;&lt;highlight class=&quot;normal&quot;&gt;)),&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      94 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;std::make_tuple(&lt;ref refid=&quot;structfuncl_1_1Erf&quot; kindref=&quot;compound&quot;&gt;funcl::Erf&amp;lt;&amp;gt;&lt;/ref&gt;{},&lt;sp/&gt;std::make_tuple(&lt;/highlight&gt;&lt;highlight class=&quot;keyword&quot;&gt;generic&lt;/highlight&gt;&lt;highlight class=&quot;normal&quot;&gt;)),&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      95 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;std::make_tuple(&lt;ref refid=&quot;structfuncl_1_1Exp&quot; kindref=&quot;compound&quot;&gt;funcl::Exp&amp;lt;&amp;gt;&lt;/ref&gt;{},&lt;sp/&gt;std::make_tuple(&lt;/highlight&gt;&lt;highlight class=&quot;keyword&quot;&gt;generic&lt;/highlight&gt;&lt;highlight class=&quot;normal&quot;&gt;)),&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      96 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;std::make_tuple(&lt;ref refid=&quot;structfuncl_1_1Exp2&quot; kindref=&quot;compound&quot;&gt;funcl::Exp2&amp;lt;&amp;gt;&lt;/ref&gt;{},&lt;sp/&gt;std::make_tuple(&lt;/highlight&gt;&lt;highlight class=&quot;keyword&quot;&gt;generic&lt;/highlight&gt;&lt;highlight class=&quot;normal&quot;&gt;)),&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      97 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;std::make_tuple(&lt;ref refid=&quot;structfuncl_1_1Fabs&quot; kindref=&quot;compound&quot;&gt;funcl::Fabs&amp;lt;&amp;gt;&lt;/ref&gt;{},&lt;sp/&gt;std::make_tuple(&lt;/highlight&gt;&lt;highlight class=&quot;keyword&quot;&gt;generic&lt;/highlight&gt;&lt;highlight class=&quot;normal&quot;&gt;)),&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      98 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;std::make_tuple(&lt;ref refid=&quot;structfuncl_1_1InvCbrt&quot; kindref=&quot;compound&quot;&gt;funcl::InvCbrt&amp;lt;&amp;gt;&lt;/ref&gt;{},&lt;sp/&gt;std::make_tuple(&lt;/highlight&gt;&lt;highlight class=&quot;keyword&quot;&gt;generic&lt;/highlight&gt;&lt;highlight class=&quot;normal&quot;&gt;)),&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">      99 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;std::make_tuple(&lt;ref refid=&quot;structfuncl_1_1InvSqrt&quot; kindref=&quot;compound&quot;&gt;funcl::InvSqrt&amp;lt;&amp;gt;&lt;/ref&gt;{},&lt;sp/&gt;std::make_tuple(positive)),&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">     100 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;std::make_tuple(&lt;ref refid=&quot;structfuncl_1_1Log&quot; kindref=&quot;compound&quot;&gt;funcl::Log&amp;lt;&amp;gt;&lt;/ref&gt;{},&lt;sp/&gt;std::make_tuple(positive)),&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">     101 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;std::make_tuple(&lt;ref refid=&quot;structfuncl_1_1Log10&quot; kindref=&quot;compound&quot;&gt;funcl::Log10&amp;lt;&amp;gt;&lt;/ref&gt;{},&lt;sp/&gt;std::make_tuple(positive)),&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">     102 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;std::make_tuple(&lt;ref refid=&quot;structfuncl_1_1Log2&quot; kindref=&quot;compound&quot;&gt;funcl::Log2&amp;lt;&amp;gt;&lt;/ref&gt;{},&lt;sp/&gt;std::make_tuple(positive)),&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">     103 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;std::make_tuple(&lt;ref refid=&quot;structfuncl_1_1Sin&quot; kindref=&quot;compound&quot;&gt;funcl::Sin&amp;lt;&amp;gt;&lt;/ref&gt;{},&lt;sp/&gt;std::make_tuple(&lt;/highlight&gt;&lt;highlight class=&quot;keyword&quot;&gt;generic&lt;/highlight&gt;&lt;highlight class=&quot;normal&quot;&gt;)),&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">     104 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;std::make_tuple(&lt;ref refid=&quot;structfuncl_1_1Sinh&quot; kindref=&quot;compound&quot;&gt;funcl::Sinh&amp;lt;&amp;gt;&lt;/ref&gt;{},&lt;sp/&gt;std::make_tuple(&lt;/highlight&gt;&lt;highlight class=&quot;keyword&quot;&gt;generic&lt;/highlight&gt;&lt;highlight class=&quot;normal&quot;&gt;)),&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">     105 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;std::make_tuple(&lt;ref refid=&quot;structfuncl_1_1StepFunction&quot; kindref=&quot;compound&quot;&gt;funcl::StepFunction&amp;lt;&amp;gt;&lt;/ref&gt;{},&lt;sp/&gt;std::make_tuple(&lt;/highlight&gt;&lt;highlight class=&quot;keyword&quot;&gt;generic&lt;/highlight&gt;&lt;highlight class=&quot;normal&quot;&gt;)),&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">     106 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;std::make_tuple(&lt;ref refid=&quot;structfuncl_1_1Square&quot; kindref=&quot;compound&quot;&gt;funcl::Square&amp;lt;&amp;gt;&lt;/ref&gt;{},&lt;sp/&gt;std::make_tuple(&lt;/highlight&gt;&lt;highlight class=&quot;keyword&quot;&gt;generic&lt;/highlight&gt;&lt;highlight class=&quot;normal&quot;&gt;)),&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">     107 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;std::make_tuple(&lt;ref refid=&quot;structfuncl_1_1Sqrt&quot; kindref=&quot;compound&quot;&gt;funcl::Sqrt&amp;lt;&amp;gt;&lt;/ref&gt;{},&lt;sp/&gt;std::make_tuple(positive)),&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">     108 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;std::make_tuple(&lt;ref refid=&quot;structfuncl_1_1Tan&quot; kindref=&quot;compound&quot;&gt;funcl::Tan&amp;lt;&amp;gt;&lt;/ref&gt;{},&lt;sp/&gt;std::make_tuple(&lt;/highlight&gt;&lt;highlight class=&quot;keyword&quot;&gt;generic&lt;/highlight&gt;&lt;highlight class=&quot;normal&quot;&gt;)),&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">     109 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;std::make_tuple(&lt;ref refid=&quot;structfuncl_1_1Tanh&quot; kindref=&quot;compound&quot;&gt;funcl::Tanh&amp;lt;&amp;gt;&lt;/ref&gt;{},&lt;sp/&gt;std::make_tuple(&lt;/highlight&gt;&lt;highlight class=&quot;keyword&quot;&gt;generic&lt;/highlight&gt;&lt;highlight class=&quot;normal&quot;&gt;)),&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">     110 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;std::make_tuple(&lt;ref refid=&quot;structfuncl_1_1UnaryPow&quot; kindref=&quot;compound&quot;&gt;funcl::UnaryPow&amp;lt;1&amp;gt;&lt;/ref&gt;{},&lt;sp/&gt;std::make_tuple(&lt;/highlight&gt;&lt;highlight class=&quot;keyword&quot;&gt;generic&lt;/highlight&gt;&lt;highlight class=&quot;normal&quot;&gt;)),&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">     111 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;std::make_tuple(&lt;ref refid=&quot;structfuncl_1_1UnaryPow&quot; kindref=&quot;compound&quot;&gt;funcl::UnaryPow&amp;lt;-2&amp;gt;&lt;/ref&gt;{},&lt;sp/&gt;std::make_tuple(&lt;/highlight&gt;&lt;highlight class=&quot;keyword&quot;&gt;generic&lt;/highlight&gt;&lt;highlight class=&quot;normal&quot;&gt;)),&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">     112 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;std::make_tuple(&lt;ref refid=&quot;structfuncl_1_1UnaryPow&quot; kindref=&quot;compound&quot;&gt;funcl::UnaryPow&amp;lt;3&amp;gt;&lt;/ref&gt;{},&lt;sp/&gt;std::make_tuple(&lt;/highlight&gt;&lt;highlight class=&quot;keyword&quot;&gt;generic&lt;/highlight&gt;&lt;highlight class=&quot;normal&quot;&gt;)));&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">     113 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">     114 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;ref refid=&quot;group__TestingFrameworkGroup_1ga990527392f1401e09d2d9799b1a663a7&quot; kindref=&quot;member&quot;&gt;TestHelpers::VectorImpl::test_functions_with_vector_arguments&lt;/ref&gt;&amp;lt;&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">     115 </span>            : &lt;codeline&gt;&lt;highlight class=&quot;normal&quot;&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;&lt;sp/&gt;TestHelpers::VectorImpl::TestKind::Normal,&lt;sp/&gt;&lt;ref refid=&quot;classDataVector&quot; kindref=&quot;compound&quot;&gt;DataVector&lt;/ref&gt;&amp;gt;(unary_ops);&lt;/highlight&gt;&lt;/codeline&gt;
<span class="lineNum">     116 </span>            : &lt;/programlisting&gt; More use cases of this functionality can be found in &lt;computeroutput&gt;Test_DataVector.cpp&lt;/computeroutput&gt;.&lt;/para&gt;&lt;/sect1&gt;
<span class="lineNum">     117 </span>            : &lt;sect1 id=&quot;implementing_vectors_1Vector_storage&quot;&gt;
<span class="lineNum">     118 </span>            : &lt;title&gt;Vector storage nuts and bolts&lt;/title&gt;
<span class="lineNum">     119 </span>            : &lt;para&gt;Internally, all vector classes inherit from the templated &lt;computeroutput&gt;&lt;ref refid=&quot;classVectorImpl&quot; kindref=&quot;compound&quot;&gt;VectorImpl&lt;/ref&gt;&lt;/computeroutput&gt;, which inherits from &lt;computeroutput&gt;&lt;ref refid=&quot;structPointerVector&quot; kindref=&quot;compound&quot;&gt;PointerVector&lt;/ref&gt;&lt;/computeroutput&gt;, which inherits from a &lt;computeroutput&gt;blaze::DenseVector&lt;/computeroutput&gt;. Most of the mathematical operations are supported through the Blaze inheritance, which ensures that the math operations execute the optimized forms in Blaze.&lt;/para&gt;&lt;para&gt;SpECTRE vectors can be either &amp;quot;owning&amp;quot; or &amp;quot;non-owning&amp;quot;. If a vector is owning, it allocates and controls the data it has access to, and is responsible for eventually freeing that data when the vector goes out of scope. If the vector is non-owning, it acts as a (possibly complete) &amp;quot;view&amp;quot; of otherwise allocated memory. Non-owning vectors do not manage memory, nor can they change size. The two cases of data ownership cause the underlying data to be handled fairly differently, so we will discuss each in turn.&lt;/para&gt;&lt;para&gt;In both cases of ownership, the base &lt;computeroutput&gt;&lt;ref refid=&quot;structPointerVector&quot; kindref=&quot;compound&quot;&gt;PointerVector&lt;/ref&gt;&lt;/computeroutput&gt; contains a pointer to the allocated contiguous block of memory via a raw pointer &lt;computeroutput&gt;v_&lt;/computeroutput&gt; (accessible via &lt;computeroutput&gt;PointerVector.data()&lt;/computeroutput&gt; and the extent of that memory &lt;computeroutput&gt;size_&lt;/computeroutput&gt; (accessible via &lt;computeroutput&gt;PointerVector.size()&lt;/computeroutput&gt;). The raw pointer in &lt;computeroutput&gt;&lt;ref refid=&quot;structPointerVector&quot; kindref=&quot;compound&quot;&gt;PointerVector&lt;/ref&gt;&lt;/computeroutput&gt; then gives access to the memory block to the base Blaze types, which perform the work of the actual math operations. &lt;computeroutput&gt;&lt;ref refid=&quot;structPointerVector&quot; kindref=&quot;compound&quot;&gt;PointerVector&lt;/ref&gt;&lt;/computeroutput&gt; is closely patterned off of Blaze internal functionality (&lt;computeroutput&gt;CustomVector&lt;/computeroutput&gt;), and we stress that direct alteration of &lt;computeroutput&gt;&lt;ref refid=&quot;structPointerVector&quot; kindref=&quot;compound&quot;&gt;PointerVector&lt;/ref&gt;&lt;/computeroutput&gt; should be avoided unless completely necessary. The discussion in this section is intended to provide a better understanding of how the interface is used for the SpECTRE vector types so that future customization of derived classes of &lt;computeroutput&gt;&lt;ref refid=&quot;classVectorImpl&quot; kindref=&quot;compound&quot;&gt;VectorImpl&lt;/ref&gt;&lt;/computeroutput&gt; is as easy as possible.&lt;/para&gt;&lt;para&gt;When a SpECTRE vector is constructed as owning, or becomes owning, it allocates its own block of memory of appropriate size, and stores a pointer to that memory in a &lt;computeroutput&gt;&lt;ref refid=&quot;cpp/memory/unique_ptr&quot; kindref=&quot;compound&quot; external=&quot;/work/spectre/docs/config/cppreference-doxygen-web.tag.xml&quot;&gt;std::unique_ptr&lt;/ref&gt;&lt;/computeroutput&gt; named &lt;computeroutput&gt;owned_data_&lt;/computeroutput&gt;. The &lt;computeroutput&gt;&lt;ref refid=&quot;cpp/memory/unique_ptr&quot; kindref=&quot;compound&quot; external=&quot;/work/spectre/docs/config/cppreference-doxygen-web.tag.xml&quot;&gt;std::unique_ptr&lt;/ref&gt;&lt;/computeroutput&gt; ensures that the SpECTRE vector needs to perform no further direct memory management, and that the memory will be appropriately managed whenever the &lt;computeroutput&gt;&lt;ref refid=&quot;cpp/memory/unique_ptr&quot; kindref=&quot;compound&quot; external=&quot;/work/spectre/docs/config/cppreference-doxygen-web.tag.xml&quot;&gt;std::unique_ptr&lt;/ref&gt; owned_data_&lt;/computeroutput&gt; member is deleted or moved. The base &lt;computeroutput&gt;&lt;ref refid=&quot;structPointerVector&quot; kindref=&quot;compound&quot;&gt;PointerVector&lt;/ref&gt;&lt;/computeroutput&gt; must also be told about the pointer, which is always accomplished by calling the protected function &lt;computeroutput&gt;VectorImpl.reset_pointer_vector(const size_t set_size)&lt;/computeroutput&gt;, which sets the &lt;computeroutput&gt;&lt;ref refid=&quot;structPointerVector&quot; kindref=&quot;compound&quot;&gt;PointerVector&lt;/ref&gt;&lt;/computeroutput&gt; internal pointer to the pointer obtained by &lt;computeroutput&gt;std::unique_pointer.get()&lt;/computeroutput&gt;.&lt;/para&gt;&lt;para&gt;When a SpECTRE vector is constructed as non-owning by the &lt;computeroutput&gt;&lt;ref refid=&quot;classVectorImpl&quot; kindref=&quot;compound&quot;&gt;VectorImpl&lt;/ref&gt;(ValueType* start, size_t set_size)&lt;/computeroutput&gt; constructor, or becomes non-owning by the &lt;computeroutput&gt;set_data_ref&lt;/computeroutput&gt; function, the internal &lt;computeroutput&gt;&lt;ref refid=&quot;cpp/memory/unique_ptr&quot; kindref=&quot;compound&quot; external=&quot;/work/spectre/docs/config/cppreference-doxygen-web.tag.xml&quot;&gt;std::unique_ptr&lt;/ref&gt;&lt;/computeroutput&gt; named &lt;computeroutput&gt;owned_data_&lt;/computeroutput&gt; no longer points to the data represented by the vector and can be thought of as &amp;quot;inactive&amp;quot; for the purposes of computation and memory management. This behavior is desirable, because otherwise the &lt;computeroutput&gt;&lt;ref refid=&quot;cpp/memory/unique_ptr&quot; kindref=&quot;compound&quot; external=&quot;/work/spectre/docs/config/cppreference-doxygen-web.tag.xml&quot;&gt;std::unique_ptr&lt;/ref&gt;&lt;/computeroutput&gt; would attempt to free memory that is presumed to be also used elsewhere, causing difficult to diagnose memory errors. The non-owning SpECTRE vector updates the base &lt;computeroutput&gt;&lt;ref refid=&quot;structPointerVector&quot; kindref=&quot;compound&quot;&gt;PointerVector&lt;/ref&gt;&lt;/computeroutput&gt; pointer directly by calling &lt;computeroutput&gt;PointerVector.reset&lt;/computeroutput&gt; from the derived class (on itself). &lt;/para&gt;&lt;/sect1&gt;
<span class="lineNum">     120 </span>            :     &lt;/detaileddescription&gt;
<span class="lineNum">     121 </span>            :   &lt;/compounddef&gt;
<span class="lineNum">     122 </span>            : &lt;/doxygen&gt;
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
