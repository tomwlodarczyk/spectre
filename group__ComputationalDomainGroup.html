<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.8.13"/>
    <style>
        /*!
         * IE10 viewport hack for Surface/desktop Windows 8 bug
         * Copyright 2014-2015 Twitter, Inc.
         * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
         */
        @-webkit-viewport { width: device-width; }
        @-moz-viewport    { width: device-width; }
        @-ms-viewport     { width: device-width; }
        @-o-viewport      { width: device-width; }
        @viewport         { width: device-width; }
      </style>
  <title>SpECTRE: Computational Domain</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js", "color.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
MathJax.Hub.Config({
    TeX: { equationNumbers: { autoNumber: "AMS" } }
});
MathJax.Hub.Config({
    tex2jax: {inlineMath: [['^^','^^'], ['\\(', '\\)']]}
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="bootstrap.min.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="popper.min.js"></script>
  <script type="text/javascript" src="bootstrap.min.js"></script>
  <script type="text/javascript" src="spectre.js"></script>
  </head>
  <body>
  <div id="top" class="navbar-fixed-top"><!-- do not remove this div, it is closed by doxygen! -->
  <!-- BEGIN TITLEAREA -->
  <div id="titlearea">
  <script type="text/javascript">
  var searchBox = new SearchBox("searchBox", "search",false,'Search');
  </script>
  <div id="main-nav">
    <ul class="sm sm-dox" id="main-menu">
      <li>
      <a href="index.html">
      SpECTRE &#160;
        <span id="projectnumber">v0.0.0</span>
      </a>
      </li>
      <li class="dropdown">
        <a class="dropdown-toggle" data-toggle="dropdown" href="#" id="selected">
          <span id="selected">
            <i class="octicon octicon-book"></i><span>Documentation</span>
          </span>
          <span class="caret"></span>
        </a>
        <ul class="dropdown-menu">
          <li style="min-width: 135px;">
            <a href="index.html">
            <i class="octicon octicon-book"></i><span>Introduction</span></a>
          </li>
          <li style="min-width: 135px;">
            <a href="installation.html">
              <i class="octicon octicon-desktop-download"></i><span>Installation</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="tutorials.html">
              <i class="octicon octicon-mortar-board"></i><span>User Tutorials</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="dev_guide.html">
              <i class="octicon octicon-gist-secret"></i><span>Dev Guide</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="code_of_conduct.html">
              <i class="octicon octicon-comment-discussion"></i><span>Code of Conduct</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="contributing_to_spectre.html">
              <i class="octicon octicon-git-pull-request"></i><span>Contributing Guide</span>
            </a>
          </li>
        </ul>
      </li>
      <li class="dropdown">
        <a class="dropdown-toggle" data-toggle="dropdown" href="#" id="selected">
          <span id="selected">
            <i class="octicon octicon-code"></i>
              <span>Code Reference</span>
          </span>
          <span class="caret"></span>
        </a>
        <ul class="dropdown-menu">
          <li style="min-width: 130px;">
            <a href="modules.html">
              <i class="octicon octicon-code"></i>
              <span>Topics</span>
            </a>
          </li>
          <li style="min-width: 130px;">
            <a href="namespaces.html">
              <i class="octicon octicon-gist"></i>
              <span>Namespaces</span>
            </a>
          </li>
        </ul>
      </li>
      <li>
        <a href="files.html">
          <i class="octicon octicon-file-directory"></i><span>Files</span>
        </a>
      </li>
      <li>
        <a href="citelist.html">
          <i class="octicon octicon-file-text"></i><span>Bibliography</span>
        </a>
      </li>
      <li>
        <a href="https://github.com/sxs-collaboration/spectre" target="_blank">
          <i class="octicon octicon-mark-github"></i><span>View on GitHub</span>
        </a>
      </li>
      <!--The Search <li> is added by doxygen later-->
    </ul>
  </div><!-- main-nav -->
  </div><!-- titlearea -->
  <!-- window showing the filter options -->
  <div id="MSearchSelectWindow"  style="position: fixed;"
       onmouseover="return searchBox.OnSearchSelectShow()"
       onmouseout="return searchBox.OnSearchSelectHide()"
       onkeydown="return searchBox.OnSearchSelectKey(event)">
  </div>
  <!-- iframe showing the search results (closed by default) -->
  <div id="MSearchResultsWindow"  style="position: fixed;">
  <iframe src="javascript:void(0)" frameborder="0"
          name="MSearchResults" id="MSearchResults">
  </iframe>
  </div>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Computational Domain</div>  </div>
</div><!--header-->
<div class="contents">

<p>The building blocks used to describe the computational domain.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceamr"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceamr.html">amr</a></td></tr>
<tr class="memdesc:namespaceamr"><td class="mdescLeft">&#160;</td><td class="mdescRight">Items for adaptive mesh refinement. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedomain_1_1creators"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedomain_1_1creators.html">domain::creators</a></td></tr>
<tr class="memdesc:namespacedomain_1_1creators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines classes that create Domains. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlock.html">Block&lt; VolumeDim, TargetFrame &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root node of a tree which is used to construct the Elements that cover a region of the computational domain.  <a href="classBlock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdomain_1_1BlockId.html">domain::BlockId</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classIndex.html" title="An integer multi-index. ">Index</a> a block of the computational domain.  <a href="classdomain_1_1BlockId.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockNeighbor.html">BlockNeighbor&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about the neighbor of a host <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a> in a particular direction.  <a href="classBlockNeighbor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomainCreator.html">DomainCreator&lt; VolumeDim, TargetFrame &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for creating Domains from an option string.  <a href="classDomainCreator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDirection.html">Direction&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A particular Side along a particular coordinate Axis.  <a href="classDirection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDirectionHash.html">DirectionHash&lt; Dim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a perfect hash if the size of the hash table is <code>2 * Dim</code>. To take advantage of this, use the <code><a class="el" href="classFixedHashMap.html" title="A hash table with a compile-time specified maximum size and ability to efficiently handle perfect has...">FixedHashMap</a></code> class.  <a href="structDirectionHash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDirectionMap.html">DirectionMap&lt; Dim, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An optimized map with <a class="el" href="classDirection.html" title="A particular Side along a particular coordinate Axis. ">Direction</a> keys.  <a href="classDirectionMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html">Domain&lt; VolumeDim, TargetFrame &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around a vector of Blocks that represent the computational domain.  <a href="classDomain.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPairOfFaces.html">PairOfFaces</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each member in <code><a class="el" href="structPairOfFaces.html" title="Each member in PairOfFaces holds the global corner ids of a block face. PairOfFaces is used in settin...">PairOfFaces</a></code> holds the global corner ids of a block face. <code><a class="el" href="structPairOfFaces.html" title="Each member in PairOfFaces holds the global corner ids of a block face. PairOfFaces is used in settin...">PairOfFaces</a></code> is used in setting up periodic boundary conditions by identifying the two faces with each other.  <a href="structPairOfFaces.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVolumeCornerIterator.html">VolumeCornerIterator&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates over the corners of a VolumeDim-dimensional cube.  <a href="classVolumeCornerIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFaceCornerIterator.html">FaceCornerIterator&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterates over the 2^(VolumeDim-1) logical corners of the face of a VolumeDim-dimensional cube in the given direction.  <a href="classFaceCornerIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html">Element&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A spectral element with knowledge of its neighbors.  <a href="classElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElementId.html">ElementId&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classElementId.html" title="An ElementId uniquely labels an Element. It is constructed from the BlockId of the Block to which the...">ElementId</a> uniquely labels an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors. ">Element</a>. It is constructed from the BlockId of the <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a> to which the <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors. ">Element</a> belongs and the VolumeDim SegmentIds that label the segments of the <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a> that the <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors. ">Element</a> covers.  <a href="classElementId.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structElementLogicalCoordHolder.html">ElementLogicalCoordHolder&lt; Dim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds element logical coordinates of an arbitrary set of points on a single <code><a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors. ">Element</a></code>. The arbitrary set of points is assumed to be a subset of a larger set of points spanning multiple <code><a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors. ">Element</a></code>s, and this class holds <code>offsets</code> that index into that larger set of points.  <a href="structElementLogicalCoordHolder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElementMap.html">ElementMap&lt; Dim, TargetFrame &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CoordinateMap for the <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors. ">Element</a> from the Logical frame to the <code>TargetFrame</code>  <a href="classElementMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTags_1_1UnnormalizedFaceNormal.html">Tags::UnnormalizedFaceNormal&lt; VolumeDim, Frame &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The unnormalized face normal one form.  <a href="structTags_1_1UnnormalizedFaceNormal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTags_1_1InterfaceCompute_3_01Tags_1_1BoundaryDirectionsExterior_3_01VolumeDim_01_4_00_01Un636a1e7ffc290df670f6c74b164d4988.html">Tags::InterfaceCompute&lt; Tags::BoundaryDirectionsExterior&lt; VolumeDim &gt;, UnnormalizedFaceNormalCompute&lt; VolumeDim, Frame &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialisation of <a class="el" href="structTags_1_1UnnormalizedFaceNormal.html" title="The unnormalized face normal one form. ">UnnormalizedFaceNormal</a> for the external boundaries which inverts the normals. Since ExternalBoundariesDirections are meant to represent ghost elements, the normals should correspond to the normals in said element, which are inverted with respect to the current element.  <a href="structTags_1_1InterfaceCompute_3_01Tags_1_1BoundaryDirectionsExterior_3_01VolumeDim_01_4_00_01Un636a1e7ffc290df670f6c74b164d4988.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTags_1_1InterfaceCompute.html">Tags::InterfaceCompute&lt; DirectionsTag, Tag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived tag for representing a compute item which acts on Tags on an interface. Can be retrieved using Tags::Interface&lt;DirectionsTag, Tag&gt;  <a href="structTags_1_1InterfaceCompute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTags_1_1Slice.html">Tags::Slice&lt; DirectionsTag, Tag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived tag for representing a compute item which slices a Tag containing a <code>Tensor</code> or a <code><a class="el" href="structTags_1_1Variables.html">Variables</a></code> from the volume to an interface. Retrievable from the <a class="el" href="structTags_1_1DataBox.html" title="Tag used to retrieve the DataBox from the db::get function. ">DataBox</a> using <code><a class="el" href="structTags_1_1Interface.html" title="Tag which is either a SimpleTag for quantities on an interface, base tag to a compute item which acts...">Tags::Interface</a>&lt;DirectionsTag, Tag&gt;</code>  <a href="structTags_1_1Slice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTags_1_1InterfaceMesh.html">Tags::InterfaceMesh&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the <code>VolumeDim-1</code> dimensional mesh on an interface from the volume mesh. <code><a class="el" href="structTags_1_1InterfaceCompute.html" title="Derived tag for representing a compute item which acts on Tags on an interface. Can be retrieved usin...">Tags::InterfaceCompute</a>&lt;Dirs, <a class="el" href="structTags_1_1InterfaceMesh.html" title="Computes the VolumeDim-1 dimensional mesh on an interface from the volume mesh. Tags::InterfaceComput...">InterfaceMesh</a>&lt;VolumeDim&gt;&gt;</code> is retrievable as <a class="el" href="structTags_1_1Interface.html" title="Tag which is either a SimpleTag for quantities on an interface, base tag to a compute item which acts...">Tags::Interface</a>&lt;Dirs, <a class="el" href="classMesh.html">Mesh&lt;VolumeDim&gt;</a>&gt;` from the <a class="el" href="structTags_1_1DataBox.html" title="Tag used to retrieve the DataBox from the db::get function. ">DataBox</a>.  <a href="structTags_1_1InterfaceMesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTags_1_1LogicalCoordinates.html">Tags::LogicalCoordinates&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The logical coordinates in the <a class="el" href="structTags_1_1Element.html" title="The Element associated with the DataBox. ">Element</a>.  <a href="structTags_1_1LogicalCoordinates.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTags_1_1MinimumGridSpacing.html">Tags::MinimumGridSpacing&lt; Dim, Frame &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minimum coordinate distance between grid points.  <a href="structTags_1_1MinimumGridSpacing.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeighbors.html">Neighbors&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about the neighbors of a host <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors. ">Element</a> in a particular direction.  <a href="classNeighbors.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSegmentId.html">SegmentId</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classSegmentId.html" title="A SegmentId labels a segment of the interval [-1,1] and is used to identify the bounds of an Element ...">SegmentId</a> labels a segment of the interval [-1,1] and is used to identify the bounds of an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors. ">Element</a> in a <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a> in each dimension.  <a href="classSegmentId.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTags_1_1SizeOfElement.html">Tags::SizeOfElement&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inertial-coordinate size of an element along each of its logical directions.  <a href="structTags_1_1SizeOfElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOptionTags_1_1DomainCreator.html">OptionTags::DomainCreator&lt; Dim, TargetFrame &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The input file tag for the <a class="el" href="structOptionTags_1_1DomainCreator.html" title="The input file tag for the DomainCreator to use. ">DomainCreator</a> to use.  <a href="structOptionTags_1_1DomainCreator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTags_1_1Domain.html">Tags::Domain&lt; VolumeDim, Frame &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classDomain.html" title="A wrapper around a vector of Blocks that represent the computational domain. ">Domain</a>.  <a href="structTags_1_1Domain.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTags_1_1InitialExtents.html">Tags::InitialExtents&lt; Dim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of grid points per dimension for all elements in each block of the initial computational domain.  <a href="structTags_1_1InitialExtents.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTags_1_1InitialRefinementLevels.html">Tags::InitialRefinementLevels&lt; Dim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The initial refinement level per dimension for all elements in each block of the initial computational domain.  <a href="structTags_1_1InitialRefinementLevels.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTags_1_1Element.html">Tags::Element&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors. ">Element</a> associated with the <a class="el" href="structTags_1_1DataBox.html" title="Tag used to retrieve the DataBox from the db::get function. ">DataBox</a>.  <a href="structTags_1_1Element.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTags_1_1Mesh.html">Tags::Mesh&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The computational grid of the <a class="el" href="structTags_1_1Element.html" title="The Element associated with the DataBox. ">Element</a> in the <a class="el" href="structTags_1_1DataBox.html" title="Tag used to retrieve the DataBox from the db::get function. ">DataBox</a>.  <a href="structTags_1_1Mesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTags_1_1ElementMap.html">Tags::ElementMap&lt; VolumeDim, Frame &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The coordinate map from logical to grid coordinate.  <a href="structTags_1_1ElementMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTags_1_1Coordinates.html">Tags::Coordinates&lt; Dim, Frame &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The coordinates in a given frame.  <a href="structTags_1_1Coordinates.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTags_1_1MappedCoordinates.html">Tags::MappedCoordinates&lt; MapTag, SourceCoordsTag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The coordinates in the target frame of <code>MapTag</code>. The <code>SourceCoordsTag</code>'s frame must be the source frame of <code>MapTag</code>  <a href="structTags_1_1MappedCoordinates.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTags_1_1InverseJacobian.html">Tags::InverseJacobian&lt; MapTag, SourceCoordsTag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse Jacobian of the map held by <code>MapTag</code> at the coordinates held by <code>SourceCoordsTag</code>. The coordinates must be in the source frame of the map.  <a href="structTags_1_1InverseJacobian.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTags_1_1InternalDirections.html">Tags::InternalDirections&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of directions to neighboring Elements.  <a href="structTags_1_1InternalDirections.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTags_1_1BoundaryDirectionsInterior.html">Tags::BoundaryDirectionsInterior&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of directions which correspond to external boundaries. Used for representing data on the interior side of the external boundary faces.  <a href="structTags_1_1BoundaryDirectionsInterior.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTags_1_1BoundaryDirectionsExterior.html">Tags::BoundaryDirectionsExterior&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of directions which correspond to external boundaries. To be used to represent data which exists on the exterior side of the external boundary faces.  <a href="structTags_1_1BoundaryDirectionsExterior.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTags_1_1Interface.html">Tags::Interface&lt; DirectionsTag, Tag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag which is either a SimpleTag for quantities on an interface, base tag to a compute item which acts on tags on an interface, or base tag to a compute item which slices a tag from the volume to an interface.  <a href="structTags_1_1Interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTags_1_1Direction.html">Tags::Direction&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classDirection.html" title="A particular Side along a particular coordinate Axis. ">Direction</a> to an interface  <a href="structTags_1_1Direction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga6874579f1400ff7d0d77cbfa978289e2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga6874579f1400ff7d0d77cbfa978289e2">amr::Flag</a> { <br />
&#160;&#160;<a class="el" href="group__ComputationalDomainGroup.html#gga6874579f1400ff7d0d77cbfa978289e2aec0fc0100c4fc1ce4eea230c3dc10360">amr::Flag::Undefined</a>, 
<a class="el" href="group__ComputationalDomainGroup.html#gga6874579f1400ff7d0d77cbfa978289e2aa286d9991c6a547ae25a5f5216164b8f">amr::Flag::Join</a>, 
<a class="el" href="group__ComputationalDomainGroup.html#gga6874579f1400ff7d0d77cbfa978289e2ae566bdf06d954aec108ff063196a4147">amr::Flag::DecreaseResolution</a>, 
<a class="el" href="group__ComputationalDomainGroup.html#gga6874579f1400ff7d0d77cbfa978289e2a71b7f3fcd4098ebf8a3b387579d90dd7">amr::Flag::DoNothing</a>, 
<br />
&#160;&#160;<a class="el" href="group__ComputationalDomainGroup.html#gga6874579f1400ff7d0d77cbfa978289e2a1f8c283304e4a6a17283ca12b9868273">amr::Flag::IncreaseResolution</a>, 
<a class="el" href="group__ComputationalDomainGroup.html#gga6874579f1400ff7d0d77cbfa978289e2a8a9e64d86ed12ad40de129bc7f4683b2">amr::Flag::Split</a>
<br />
 }<tr class="memdesc:ga6874579f1400ff7d0d77cbfa978289e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags that represent decisions about mesh refinement.  <a href="group__ComputationalDomainGroup.html#ga6874579f1400ff7d0d77cbfa978289e2">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga6874579f1400ff7d0d77cbfa978289e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac672a529d9aaa6a948b8b7eb6ec9b528"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gac672a529d9aaa6a948b8b7eb6ec9b528">ShellWedges</a> { <a class="el" href="group__ComputationalDomainGroup.html#ggac672a529d9aaa6a948b8b7eb6ec9b528ab1c94ca2fbc3e78fc30069c8d0f01680">ShellWedges::All</a>, 
<a class="el" href="group__ComputationalDomainGroup.html#ggac672a529d9aaa6a948b8b7eb6ec9b528ace553534ea34f25db4b4a8b5bd29cf45">ShellWedges::FourOnEquator</a>, 
<a class="el" href="group__ComputationalDomainGroup.html#ggac672a529d9aaa6a948b8b7eb6ec9b528ae9d8dbfbf81de7cf729066f677661edb">ShellWedges::OneAlongMinusX</a>
 }<tr class="memdesc:gac672a529d9aaa6a948b8b7eb6ec9b528"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of wedges to include in the Shell domain.  <a href="group__ComputationalDomainGroup.html#gac672a529d9aaa6a948b8b7eb6ec9b528">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:gac672a529d9aaa6a948b8b7eb6ec9b528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c0137d7160ad71b6ed265c53c99ed00"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga8c0137d7160ad71b6ed265c53c99ed00">Side</a> { <b>Lower</b>, 
<b>Upper</b>
 }<tr class="memdesc:ga8c0137d7160ad71b6ed265c53c99ed00"><td class="mdescLeft">&#160;</td><td class="mdescRight">A label for the side of a manifold.  <a href="group__ComputationalDomainGroup.html#ga8c0137d7160ad71b6ed265c53c99ed00">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga8c0137d7160ad71b6ed265c53c99ed00"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaefd6db279218361a4f20f85771e12aa6"><td class="memTemplParams" colspan="2"><a id="gaefd6db279218361a4f20f85771e12aa6"></a>
template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:gaefd6db279218361a4f20f85771e12aa6"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, VolumeDim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gaefd6db279218361a4f20f85771e12aa6">amr::desired_refinement_levels</a> (const <a class="el" href="classElementId.html">ElementId</a>&lt; VolumeDim &gt; &amp;id, const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="group__ComputationalDomainGroup.html#ga6874579f1400ff7d0d77cbfa978289e2">amr::Flag</a>, VolumeDim &gt; &amp;flags) noexcept</td></tr>
<tr class="memdesc:gaefd6db279218361a4f20f85771e12aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the desired refinement level of the <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors. ">Element</a> with <a class="el" href="classElementId.html" title="An ElementId uniquely labels an Element. It is constructed from the BlockId of the Block to which the...">ElementId</a> <code>id</code> given the desired <a class="el" href="group__ComputationalDomainGroup.html#ga6874579f1400ff7d0d77cbfa978289e2" title="Flags that represent decisions about mesh refinement. ">amr::Flag</a>s <code>flags</code> <br /></td></tr>
<tr class="separator:gaefd6db279218361a4f20f85771e12aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6b39332c0ebaf70aa94de13661b2e13"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:gab6b39332c0ebaf70aa94de13661b2e13"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, VolumeDim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gab6b39332c0ebaf70aa94de13661b2e13">amr::desired_refinement_levels_of_neighbor</a> (const <a class="el" href="classElementId.html">ElementId</a>&lt; VolumeDim &gt; &amp;neighbor_id, const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="group__ComputationalDomainGroup.html#ga6874579f1400ff7d0d77cbfa978289e2">amr::Flag</a>, VolumeDim &gt; &amp;neighbor_flags, const OrientationMap&lt; VolumeDim &gt; &amp;orientation) noexcept</td></tr>
<tr class="memdesc:gab6b39332c0ebaf70aa94de13661b2e13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the desired refinement level of a neighboring <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors. ">Element</a> with <a class="el" href="classElementId.html" title="An ElementId uniquely labels an Element. It is constructed from the BlockId of the Block to which the...">ElementId</a> <code>neighbor_id</code> given its desired <a class="el" href="group__ComputationalDomainGroup.html#ga6874579f1400ff7d0d77cbfa978289e2" title="Flags that represent decisions about mesh refinement. ">amr::Flag</a>s <code>neighbor_flags</code> taking into account the OrientationMap <code>orientation</code> of the neighbor.  <a href="group__ComputationalDomainGroup.html#gab6b39332c0ebaf70aa94de13661b2e13">More...</a><br /></td></tr>
<tr class="separator:gab6b39332c0ebaf70aa94de13661b2e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0e7346e59a71819c08d9efbfcb99ea2"><td class="memTemplParams" colspan="2"><a id="gaf0e7346e59a71819c08d9efbfcb99ea2"></a>
template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:gaf0e7346e59a71819c08d9efbfcb99ea2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gaf0e7346e59a71819c08d9efbfcb99ea2">amr::has_potential_sibling</a> (const <a class="el" href="classElementId.html">ElementId</a>&lt; VolumeDim &gt; &amp;element_id, const <a class="el" href="classDirection.html">Direction</a>&lt; VolumeDim &gt; &amp;direction) noexcept</td></tr>
<tr class="memdesc:gaf0e7346e59a71819c08d9efbfcb99ea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not the <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors. ">Element</a> with <code>element_id</code> can have a sibling in the given <code>direction</code> <br /></td></tr>
<tr class="separator:gaf0e7346e59a71819c08d9efbfcb99ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0adec4b3b909be2df0e6f9ef4d5615f1"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga0adec4b3b909be2df0e6f9ef4d5615f1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga0adec4b3b909be2df0e6f9ef4d5615f1">amr::update_amr_decision</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="group__ComputationalDomainGroup.html#ga6874579f1400ff7d0d77cbfa978289e2">amr::Flag</a>, VolumeDim &gt; *&gt; my_current_amr_flags, const <a class="el" href="classElement.html">Element</a>&lt; VolumeDim &gt; &amp;element, const <a class="el" href="classElementId.html">ElementId</a>&lt; VolumeDim &gt; &amp;neighbor_id, const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="group__ComputationalDomainGroup.html#ga6874579f1400ff7d0d77cbfa978289e2">amr::Flag</a>, VolumeDim &gt; &amp;neighbor_amr_flags) noexcept</td></tr>
<tr class="memdesc:ga0adec4b3b909be2df0e6f9ef4d5615f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the AMR decisions <code>my_current_amr_flags</code> of the <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors. ">Element</a> <code>element</code> based on the AMR decisions <code>neighbor_amr_flags</code> of a neighbor <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors. ">Element</a> with <a class="el" href="classElementId.html" title="An ElementId uniquely labels an Element. It is constructed from the BlockId of the Block to which the...">ElementId</a> <code>neighbor_id</code>.  <a href="group__ComputationalDomainGroup.html#ga0adec4b3b909be2df0e6f9ef4d5615f1">More...</a><br /></td></tr>
<tr class="separator:ga0adec4b3b909be2df0e6f9ef4d5615f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10f47cbc5864be98847fcd07355e3c4b"><td class="memTemplParams" colspan="2">template&lt;size_t Dim, typename Frame &gt; </td></tr>
<tr class="memitem:ga10f47cbc5864be98847fcd07355e3c4b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga10f47cbc5864be98847fcd07355e3c4b">block_logical_coordinates</a> (const <a class="el" href="classDomain.html">Domain</a>&lt; Dim, Frame &gt; &amp;domain, const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, Frame &gt; &amp;x) noexcept -&gt; <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; boost::optional&lt; <a class="el" href="structIdPair.html">IdPair</a>&lt; <a class="el" href="classdomain_1_1BlockId.html">domain::BlockId</a>, tnsr::I&lt; double, Dim, typename ::<a class="el" href="structFrame_1_1Logical.html">Frame::Logical</a> &gt;&gt;&gt;&gt;</td></tr>
<tr class="memdesc:ga10f47cbc5864be98847fcd07355e3c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the block logical coordinates and the containing <code>BlockId</code> of a set of points, given coordinates in the <code><a class="el" href="namespaceFrame.html" title="Indicates the Frame that a TensorIndexType is in. ">Frame</a></code> frame.  <a href="#ga10f47cbc5864be98847fcd07355e3c4b">More...</a><br /></td></tr>
<tr class="separator:ga10f47cbc5864be98847fcd07355e3c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c3a5bdf464227b3bf4a76b07fd2f8d4"><td class="memTemplParams" colspan="2"><a id="ga5c3a5bdf464227b3bf4a76b07fd2f8d4"></a>
template&lt;typename SourceFrame , typename TargetFrame , typename... Maps&gt; </td></tr>
<tr class="memitem:ga5c3a5bdf464227b3bf4a76b07fd2f8d4"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga5c3a5bdf464227b3bf4a76b07fd2f8d4">domain::make_coordinate_map</a> (Maps &amp;&amp;... maps) -&gt; <a class="el" href="classdomain_1_1CoordinateMap.html">CoordinateMap</a>&lt; SourceFrame, TargetFrame, <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a>&lt; Maps &gt;... &gt;</td></tr>
<tr class="memdesc:ga5c3a5bdf464227b3bf4a76b07fd2f8d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code><a class="el" href="classdomain_1_1CoordinateMap.html" title="A coordinate map or composition of coordinate maps. ">CoordinateMap</a></code> of <code>maps...</code> <br /></td></tr>
<tr class="separator:ga5c3a5bdf464227b3bf4a76b07fd2f8d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga281275a17c14e1361ab43e8079d545fc"><td class="memTemplParams" colspan="2"><a id="ga281275a17c14e1361ab43e8079d545fc"></a>
template&lt;typename SourceFrame , typename TargetFrame , typename... Maps&gt; </td></tr>
<tr class="memitem:ga281275a17c14e1361ab43e8079d545fc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga281275a17c14e1361ab43e8079d545fc">domain::make_coordinate_map_base</a> (Maps &amp;&amp;... maps) noexcept -&gt; <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1CoordinateMapBase.html">CoordinateMapBase</a>&lt; SourceFrame, TargetFrame, <a class="el" href="classdomain_1_1CoordinateMap.html">CoordinateMap</a>&lt; SourceFrame, TargetFrame, <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a>&lt; Maps &gt;... &gt;::dim &gt;&gt;</td></tr>
<tr class="memdesc:ga281275a17c14e1361ab43e8079d545fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt;<a class="el" href="classdomain_1_1CoordinateMapBase.html" title="Abstract base class for CoordinateMap. ">CoordinateMapBase</a>&gt;</code> of <code>maps...</code> <br /></td></tr>
<tr class="separator:ga281275a17c14e1361ab43e8079d545fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e72842eb76ca8b91e595319a38636ac"><td class="memTemplParams" colspan="2"><a id="ga1e72842eb76ca8b91e595319a38636ac"></a>
template&lt;typename SourceFrame , typename TargetFrame , typename Arg0 , typename... Args&gt; </td></tr>
<tr class="memitem:ga1e72842eb76ca8b91e595319a38636ac"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga1e72842eb76ca8b91e595319a38636ac">domain::make_vector_coordinate_map_base</a> (Arg0 &amp;&amp;arg_0, Args &amp;&amp;... remaining_args) noexcept -&gt; <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1CoordinateMapBase.html">CoordinateMapBase</a>&lt; SourceFrame, TargetFrame, <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a>&lt; Arg0 &gt;::dim &gt;&gt;&gt;</td></tr>
<tr class="memdesc:ga1e72842eb76ca8b91e595319a38636ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;<a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt;<a class="el" href="classdomain_1_1CoordinateMapBase.html" title="Abstract base class for CoordinateMap. ">CoordinateMapBase</a>&gt;&gt;</code> containing the result of <code>make_coordinate_map_base</code> applied to each argument passed in. <br /></td></tr>
<tr class="separator:ga1e72842eb76ca8b91e595319a38636ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada681fd92fb5c963e51df2027f7a3324"><td class="memTemplParams" colspan="2"><a id="gada681fd92fb5c963e51df2027f7a3324"></a>
template&lt;typename SourceFrame , typename TargetFrame , size_t Dim, typename Map , typename... Maps&gt; </td></tr>
<tr class="memitem:gada681fd92fb5c963e51df2027f7a3324"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gada681fd92fb5c963e51df2027f7a3324">domain::make_vector_coordinate_map_base</a> (<a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; Map &gt; maps, const Maps &amp;... remaining_maps) noexcept -&gt; <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1CoordinateMapBase.html">CoordinateMapBase</a>&lt; SourceFrame, TargetFrame, Dim &gt;&gt;&gt;</td></tr>
<tr class="memdesc:gada681fd92fb5c963e51df2027f7a3324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;<a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt;<a class="el" href="classdomain_1_1CoordinateMapBase.html" title="Abstract base class for CoordinateMap. ">CoordinateMapBase</a>&gt;&gt;</code> containing the result of <code>make_coordinate_map_base</code> applied to each element of the vector of maps composed with the rest of the arguments passed in. <br /></td></tr>
<tr class="separator:gada681fd92fb5c963e51df2027f7a3324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1ff1ab88f30d61f7d16b74b44423a4f"><td class="memTemplParams" colspan="2"><a id="gac1ff1ab88f30d61f7d16b74b44423a4f"></a>
template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:gac1ff1ab88f30d61f7d16b74b44423a4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gac1ff1ab88f30d61f7d16b74b44423a4f">set_internal_boundaries</a> (const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="group__ConstantExpressionsGroup.html#ga6c01ded3973bb4b9973e5381c32c0807">two_to_the</a>(VolumeDim)&gt;&gt; &amp;corners_of_all_blocks, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; VolumeDim, <a class="el" href="classBlockNeighbor.html">BlockNeighbor</a>&lt; VolumeDim &gt;&gt;&gt; *&gt; neighbors_of_all_blocks) noexcept</td></tr>
<tr class="memdesc:gac1ff1ab88f30d61f7d16b74b44423a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up the BlockNeighbors using the corner numbering scheme to deduce the correct neighbors and orientations. Does not set up periodic boundary conditions. <br /></td></tr>
<tr class="separator:gac1ff1ab88f30d61f7d16b74b44423a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8687ffb612868ebe6746b5e8a0e9a2b3"><td class="memTemplParams" colspan="2"><a id="ga8687ffb612868ebe6746b5e8a0e9a2b3"></a>
template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga8687ffb612868ebe6746b5e8a0e9a2b3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga8687ffb612868ebe6746b5e8a0e9a2b3">set_identified_boundaries</a> (const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="structPairOfFaces.html">PairOfFaces</a> &gt; &amp;identifications, const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="group__ConstantExpressionsGroup.html#ga6c01ded3973bb4b9973e5381c32c0807">two_to_the</a>(VolumeDim)&gt;&gt; &amp;corners_of_all_blocks, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; VolumeDim, <a class="el" href="classBlockNeighbor.html">BlockNeighbor</a>&lt; VolumeDim &gt;&gt;&gt; *&gt; neighbors_of_all_blocks) noexcept</td></tr>
<tr class="memdesc:ga8687ffb612868ebe6746b5e8a0e9a2b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up additional BlockNeighbors corresponding to any identifications of faces provided by the user. Can be used for manually setting up periodic boundary conditions. <br /></td></tr>
<tr class="separator:ga8687ffb612868ebe6746b5e8a0e9a2b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18341ca86191b511f92daf2d8c69302c"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga18341ca86191b511f92daf2d8c69302c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga18341ca86191b511f92daf2d8c69302c">corners_for_rectilinear_domains</a> (const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &amp;domain_extents, const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt;&gt; &amp;block_indices_to_exclude={}) noexcept -&gt; <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="group__ConstantExpressionsGroup.html#ga6c01ded3973bb4b9973e5381c32c0807">two_to_the</a>(VolumeDim)&gt;&gt;</td></tr>
<tr class="memdesc:ga18341ca86191b511f92daf2d8c69302c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The corners for a rectilinear domain made of n-cubes.  <a href="#ga18341ca86191b511f92daf2d8c69302c">More...</a><br /></td></tr>
<tr class="separator:ga18341ca86191b511f92daf2d8c69302c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c7f8d76aac24e2c2b383246dbe05ea8"><td class="memTemplParams" colspan="2"><a id="ga2c7f8d76aac24e2c2b383246dbe05ea8"></a>
template&lt;typename TargetFrame &gt; </td></tr>
<tr class="memitem:ga2c7f8d76aac24e2c2b383246dbe05ea8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga2c7f8d76aac24e2c2b383246dbe05ea8">wedge_coordinate_maps</a> (double inner_radius, double outer_radius, double inner_sphericity, double outer_sphericity, bool use_equiangular_map, double x_coord_of_shell_center=0.0, bool use_half_wedges=false, double aspect_ratio=1.0, bool use_logarithmic_map=false, <a class="el" href="group__ComputationalDomainGroup.html#gac672a529d9aaa6a948b8b7eb6ec9b528">ShellWedges</a> which_wedges=<a class="el" href="group__ComputationalDomainGroup.html#ggac672a529d9aaa6a948b8b7eb6ec9b528ab1c94ca2fbc3e78fc30069c8d0f01680">ShellWedges::All</a>, size_t number_of_layers=1) noexcept -&gt; <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1Logical.html">Frame::Logical</a>, TargetFrame, 3 &gt;&gt;&gt;</td></tr>
<tr class="memdesc:ga2c7f8d76aac24e2c2b383246dbe05ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">These are the CoordinateMaps of the Wedge3Ds used in the Sphere, Shell, and binary compact object DomainCreators. This function can also be used to wrap the Sphere or Shell in a cube made of six Wedge3Ds. The argument <code>x_coord_of_shell_center</code> specifies a translation of the Shell in the x-direction in the TargetFrame. For example, the BBH <a class="el" href="classDomainCreator.html" title="Base class for creating Domains from an option string. ">DomainCreator</a> uses this to set the position of each BH. When the argument <code>use_half_wedges</code> is set to <code>true</code>, the wedges in the +z,-z,+y,-y directions are cut in half along their xi-axes. The resulting ten CoordinateMaps are used for the outermost Blocks of the BBH <a class="el" href="classDomain.html" title="A wrapper around a vector of Blocks that represent the computational domain. ">Domain</a>. The argument <code>aspect_ratio</code> sets the equatorial compression factor, used by the EquatorialCompression maps which get composed with the Wedges. This is done if <code>aspect_ratio</code> is set to something other than the default value of one. When the argument <code>use_logarithmic_map</code> is set to <code>true</code>, the radial gridpoints of the wedge map are set to be spaced logarithmically. The <code>number_of_layers</code> is used when the user wants to have multiple layers of Blocks in the radial direction. <br /></td></tr>
<tr class="separator:ga2c7f8d76aac24e2c2b383246dbe05ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86534fcfbcabd6acc079b6fc38cdfbea"><td class="memTemplParams" colspan="2">template&lt;typename TargetFrame &gt; </td></tr>
<tr class="memitem:ga86534fcfbcabd6acc079b6fc38cdfbea"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga86534fcfbcabd6acc079b6fc38cdfbea">frustum_coordinate_maps</a> (double length_inner_cube, double length_outer_cube, bool use_equiangular_map, const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, 3 &gt; &amp;origin_preimage={{0.0, 0.0, 0.0}}, double projective_scale_factor=1.0) noexcept -&gt; <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1Logical.html">Frame::Logical</a>, TargetFrame, 3 &gt;&gt;&gt;</td></tr>
<tr class="memdesc:ga86534fcfbcabd6acc079b6fc38cdfbea"><td class="mdescLeft">&#160;</td><td class="mdescRight">These are the ten Frustums used in the DomainCreators for binary compact objects. The Frustums partition the volume defined by two bounding surfaces: The inner surface is the surface of the two joined inner cubes enveloping the two compact objects, while the outer is the surface of the outer cube. The cubes enveloping the two Shells each have a side length of <code>length_inner_cube</code>. The outer cube has a side length of <code>length_outer_cube</code>. <code>origin_preimage</code> is a parameter that moves the center of the two joined inner cubes away from the origin and to <code>-origin_preimage</code>. <code>projective_scale_factor</code> acts to change the gridpoint distribution in the radial direction.  <a href="#ga86534fcfbcabd6acc079b6fc38cdfbea">More...</a><br /></td></tr>
<tr class="separator:ga86534fcfbcabd6acc079b6fc38cdfbea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18526a75399d20dfb670b233fa55cff8"><td class="memItemLeft" align="right" valign="top"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, 8 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga18526a75399d20dfb670b233fa55cff8">corners_for_radially_layered_domains</a> (size_t number_of_layers, bool include_central_block, const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, 8 &gt; &amp;central_block_corners={{1, 2, 3, 4, 5, 6, 7, 8}}, <a class="el" href="group__ComputationalDomainGroup.html#gac672a529d9aaa6a948b8b7eb6ec9b528">ShellWedges</a> which_wedges=<a class="el" href="group__ComputationalDomainGroup.html#ggac672a529d9aaa6a948b8b7eb6ec9b528ab1c94ca2fbc3e78fc30069c8d0f01680">ShellWedges::All</a>) noexcept</td></tr>
<tr class="memdesc:ga18526a75399d20dfb670b233fa55cff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The corners for a domain with radial layers.  <a href="#ga18526a75399d20dfb670b233fa55cff8">More...</a><br /></td></tr>
<tr class="separator:ga18526a75399d20dfb670b233fa55cff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa76c0e8c51614f3393118e403ed35a5f"><td class="memItemLeft" align="right" valign="top"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, 8 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gaa76c0e8c51614f3393118e403ed35a5f">corners_for_biradially_layered_domains</a> (size_t number_of_radial_layers, size_t number_of_biradial_layers, bool include_central_block_lhs, bool include_central_block_rhs, const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, 8 &gt; &amp;central_block_corners_lhs={ {1, 2, 3, 4, 5, 6, 7, 8}}) noexcept</td></tr>
<tr class="memdesc:gaa76c0e8c51614f3393118e403ed35a5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The corners for a domain with biradial layers.  <a href="#gaa76c0e8c51614f3393118e403ed35a5f">More...</a><br /></td></tr>
<tr class="separator:gaa76c0e8c51614f3393118e403ed35a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c80443a66a28ba3cd542cf5f2d223c5"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga8c80443a66a28ba3cd542cf5f2d223c5"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="group__ConstantExpressionsGroup.html#ga6c01ded3973bb4b9973e5381c32c0807">two_to_the</a>(VolumeDim)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga8c80443a66a28ba3cd542cf5f2d223c5">discrete_rotation</a> (const OrientationMap&lt; VolumeDim &gt; &amp;orientation, const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="group__ConstantExpressionsGroup.html#ga6c01ded3973bb4b9973e5381c32c0807">two_to_the</a>(VolumeDim)&gt; &amp;corners_of_aligned) noexcept</td></tr>
<tr class="memdesc:ga8c80443a66a28ba3cd542cf5f2d223c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permutes the corner numbers of an n-cube.  <a href="#ga8c80443a66a28ba3cd542cf5f2d223c5">More...</a><br /></td></tr>
<tr class="separator:ga8c80443a66a28ba3cd542cf5f2d223c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fa6f4a3bbb32cae7c59d29c519ce4a3"><td class="memTemplParams" colspan="2">template&lt;typename TargetFrame , size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga2fa6f4a3bbb32cae7c59d29c519ce4a3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga2fa6f4a3bbb32cae7c59d29c519ce4a3">maps_for_rectilinear_domains</a> (const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &amp;domain_extents, const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt;, VolumeDim &gt; &amp;block_demarcations, const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt;&gt; &amp;block_indices_to_exclude={}, const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; OrientationMap&lt; VolumeDim &gt;&gt; &amp;orientations_of_all_blocks={}, bool use_equiangular_map=false) noexcept -&gt; <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1Logical.html">Frame::Logical</a>, TargetFrame, VolumeDim &gt;&gt;&gt;</td></tr>
<tr class="memdesc:ga2fa6f4a3bbb32cae7c59d29c519ce4a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CoordinateMaps for a rectilinear domain of n-cubes.  <a href="#ga2fa6f4a3bbb32cae7c59d29c519ce4a3">More...</a><br /></td></tr>
<tr class="separator:ga2fa6f4a3bbb32cae7c59d29c519ce4a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc2a358648d3b5b08419d433e9e0417c"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim, typename TargetFrame &gt; </td></tr>
<tr class="memitem:gafc2a358648d3b5b08419d433e9e0417c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDomain.html">Domain</a>&lt; VolumeDim, TargetFrame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gafc2a358648d3b5b08419d433e9e0417c">rectilinear_domain</a> (const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &amp;domain_extents, const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt;, VolumeDim &gt; &amp;block_demarcations, const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt;&gt; &amp;block_indices_to_exclude={}, const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; OrientationMap&lt; VolumeDim &gt;&gt; &amp;orientations_of_all_blocks={}, const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; bool, VolumeDim &gt; &amp;dimension_is_periodic=<a class="el" href="group__UtilitiesGroup.html#gaea51ad2c5ef8f8f99279545e1389d056">make_array</a>&lt; VolumeDim &gt;(false), const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="structPairOfFaces.html">PairOfFaces</a> &gt; &amp;identifications={}, bool use_equiangular_map=false) noexcept</td></tr>
<tr class="memdesc:gafc2a358648d3b5b08419d433e9e0417c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a rectilinear <a class="el" href="classDomain.html" title="A wrapper around a vector of Blocks that represent the computational domain. ">Domain</a> of multicubes.  <a href="#gafc2a358648d3b5b08419d433e9e0417c">More...</a><br /></td></tr>
<tr class="separator:gafc2a358648d3b5b08419d433e9e0417c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11187dd6e2dcf301fceabe0e4e4260fa"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:ga11187dd6e2dcf301fceabe0e4e4260fa"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga11187dd6e2dcf301fceabe0e4e4260fa">element_logical_coordinates</a> (const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt;&gt; &amp;element_ids, const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; boost::optional&lt; <a class="el" href="structIdPair.html">IdPair</a>&lt; <a class="el" href="classdomain_1_1BlockId.html">domain::BlockId</a>, tnsr::I&lt; double, Dim, typename <a class="el" href="structFrame_1_1Logical.html">Frame::Logical</a> &gt;&gt;&gt;&gt; &amp;block_coord_holders) noexcept -&gt; <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt;, <a class="el" href="structElementLogicalCoordHolder.html">ElementLogicalCoordHolder</a>&lt; Dim &gt;&gt;</td></tr>
<tr class="memdesc:ga11187dd6e2dcf301fceabe0e4e4260fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of points in block logical coordinates and their <code>BlockIds</code>, as returned from the function <code>block_logical_coordinates</code>, determines which <code><a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors. ">Element</a></code>s in a list of <code><a class="el" href="classElementId.html" title="An ElementId uniquely labels an Element. It is constructed from the BlockId of the Block to which the...">ElementId</a></code>s contains each point, and determines the element logical coordinates of each point.  <a href="#ga11187dd6e2dcf301fceabe0e4e4260fa">More...</a><br /></td></tr>
<tr class="separator:ga11187dd6e2dcf301fceabe0e4e4260fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5385662d879ac6f4e9dbbca5d1d9dcf"><td class="memTemplParams" colspan="2"><a id="gab5385662d879ac6f4e9dbbca5d1d9dcf"></a>
template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:gab5385662d879ac6f4e9dbbca5d1d9dcf"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gab5385662d879ac6f4e9dbbca5d1d9dcf">index_to_slice_at</a> (const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;extents, const <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt; &amp;direction) noexcept</td></tr>
<tr class="memdesc:gab5385662d879ac6f4e9dbbca5d1d9dcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index in the perpendicular dimension of an element boundary. <br /></td></tr>
<tr class="separator:gab5385662d879ac6f4e9dbbca5d1d9dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbd6da000524acf8f467d9f297ff648c"><td class="memTemplParams" colspan="2"><a id="gadbd6da000524acf8f467d9f297ff648c"></a>
template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:gadbd6da000524acf8f467d9f297ff648c"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classElementId.html">ElementId</a>&lt; VolumeDim &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gadbd6da000524acf8f467d9f297ff648c">initial_element_ids</a> (size_t block_id, <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, VolumeDim &gt; initial_ref_levs) noexcept</td></tr>
<tr class="memdesc:gadbd6da000524acf8f467d9f297ff648c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the <code><a class="el" href="classElementId.html" title="An ElementId uniquely labels an Element. It is constructed from the BlockId of the Block to which the...">ElementId</a></code>s of the a single <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a>. <br /></td></tr>
<tr class="separator:gadbd6da000524acf8f467d9f297ff648c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dc8997f1019309f79ef4ba9cc7848a8"><td class="memTemplParams" colspan="2"><a id="ga3dc8997f1019309f79ef4ba9cc7848a8"></a>
template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga3dc8997f1019309f79ef4ba9cc7848a8"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classElementId.html">ElementId</a>&lt; VolumeDim &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga3dc8997f1019309f79ef4ba9cc7848a8">initial_element_ids</a> (const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, VolumeDim &gt;&gt; &amp;initial_refinement_levels) noexcept</td></tr>
<tr class="memdesc:ga3dc8997f1019309f79ef4ba9cc7848a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the <code><a class="el" href="classElementId.html" title="An ElementId uniquely labels an Element. It is constructed from the BlockId of the Block to which the...">ElementId</a></code>s of the initial computational domain. <br /></td></tr>
<tr class="separator:ga3dc8997f1019309f79ef4ba9cc7848a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae78010c7660148ca595b42d17b38936a"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:gae78010c7660148ca595b42d17b38936a"><td class="memTemplItemLeft" align="right" valign="top">tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, <a class="el" href="structFrame_1_1Logical.html">Frame::Logical</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gae78010c7660148ca595b42d17b38936a">logical_coordinates</a> (const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim &gt; &amp;mesh) noexcept</td></tr>
<tr class="memdesc:gae78010c7660148ca595b42d17b38936a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the logical coordinates in an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors. ">Element</a>.  <a href="#gae78010c7660148ca595b42d17b38936a">More...</a><br /></td></tr>
<tr class="separator:gae78010c7660148ca595b42d17b38936a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac857ec0446d088d1d17cf96376ba8e3c"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:gac857ec0446d088d1d17cf96376ba8e3c"><td class="memTemplItemLeft" align="right" valign="top">tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, <a class="el" href="structFrame_1_1Logical.html">Frame::Logical</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gac857ec0446d088d1d17cf96376ba8e3c">interface_logical_coordinates</a> (const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim - 1 &gt; &amp;mesh, const <a class="el" href="classDirection.html">Direction</a>&lt; VolumeDim &gt; &amp;direction) noexcept</td></tr>
<tr class="memdesc:gac857ec0446d088d1d17cf96376ba8e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the logical coordinates on a face of an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors. ">Element</a>.  <a href="#gac857ec0446d088d1d17cf96376ba8e3c">More...</a><br /></td></tr>
<tr class="separator:gac857ec0446d088d1d17cf96376ba8e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa8cb44daebc8f9e080718961530be89"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gafa8cb44daebc8f9e080718961530be89">maximum_number_of_neighbors</a> (const size_t dim)</td></tr>
<tr class="memdesc:gafa8cb44daebc8f9e080718961530be89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of neighbors an element can have in <code>dim</code> dimensions.  <a href="#gafa8cb44daebc8f9e080718961530be89">More...</a><br /></td></tr>
<tr class="separator:gafa8cb44daebc8f9e080718961530be89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45ff23a83bb3bab32bd30a13bc9a41a0"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga45ff23a83bb3bab32bd30a13bc9a41a0">maximum_number_of_neighbors_per_direction</a> (const size_t dim)</td></tr>
<tr class="memdesc:ga45ff23a83bb3bab32bd30a13bc9a41a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of neighbors in each direction an element can have in <code>dim</code> dimensions.  <a href="#ga45ff23a83bb3bab32bd30a13bc9a41a0">More...</a><br /></td></tr>
<tr class="separator:ga45ff23a83bb3bab32bd30a13bc9a41a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fd6a7e52fee97306c6158477c84b71c"><td class="memTemplParams" colspan="2"><a id="ga8fd6a7e52fee97306c6158477c84b71c"></a>
template&lt;size_t Dim, typename Frame &gt; </td></tr>
<tr class="memitem:ga8fd6a7e52fee97306c6158477c84b71c"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga8fd6a7e52fee97306c6158477c84b71c">minimum_grid_spacing</a> (const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;extents, const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, Frame &gt; &amp;coords) noexcept</td></tr>
<tr class="memdesc:ga8fd6a7e52fee97306c6158477c84b71c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the minimum coordinate distance between grid points. <br /></td></tr>
<tr class="separator:ga8fd6a7e52fee97306c6158477c84b71c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b10be7003c5a457911e520865ddd91c"><td class="memTemplParams" colspan="2"><a id="ga5b10be7003c5a457911e520865ddd91c"></a>
template&lt;size_t VolumeDim, typename T &gt; </td></tr>
<tr class="memitem:ga5b10be7003c5a457911e520865ddd91c"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; tt::remove_cvref_wrap_t&lt; T &gt;, VolumeDim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga5b10be7003c5a457911e520865ddd91c">discrete_rotation</a> (const OrientationMap&lt; VolumeDim &gt; &amp;rotation, <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, VolumeDim &gt; source_coords) noexcept</td></tr>
<tr class="memdesc:ga5b10be7003c5a457911e520865ddd91c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>OrientationMap</code>s define an active rotation of the logical axes that bring the axes of a host block into alignment with the logical axes of the neighbor block. <code>discrete_rotation</code> applies this active rotation on the coordinates as opposed to the axes. For a two-dimensional example, consider a host block and a neighbor block, where the OrientationMap between them is \(\{-\eta,+\xi\}\). A quarter- turn counterclockwise of the host block's logical axes would bring them into alignment with those of the neighbor. That is, after this active rotation, the blocks would be Aligned. Now consider a point A with coordinates (+1.0,-0.5). An active quarter-turn rotation counter-clockwise about the origin, keeping the axes fixed, brings point A into the coordinates (+0.5,+1.0). This is how <code>discrete_rotation</code> interprets the <code>OrientationMap</code> passed to it. <br /></td></tr>
<tr class="separator:ga5b10be7003c5a457911e520865ddd91c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e9f4861faff254ef3ceefcd7e5dabac"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga1e9f4861faff254ef3ceefcd7e5dabac"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, VolumeDim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga1e9f4861faff254ef3ceefcd7e5dabac">size_of_element</a> (const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim &gt; &amp;mesh, const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim &gt; &amp;inertial_coords) noexcept</td></tr>
<tr class="memdesc:ga1e9f4861faff254ef3ceefcd7e5dabac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the inertial-coordinate size of an element along each of its logical directions.  <a href="#ga1e9f4861faff254ef3ceefcd7e5dabac">More...</a><br /></td></tr>
<tr class="separator:ga1e9f4861faff254ef3ceefcd7e5dabac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga417a2e1563c807ebf515d4e9fa04d425"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim, typename TargetFrame &gt; </td></tr>
<tr class="memitem:ga417a2e1563c807ebf515d4e9fa04d425"><td class="memTemplItemLeft" align="right" valign="top">tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, TargetFrame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga417a2e1563c807ebf515d4e9fa04d425">unnormalized_face_normal</a> (const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim - 1 &gt; &amp;interface_mesh, const <a class="el" href="classElementMap.html">ElementMap</a>&lt; VolumeDim, TargetFrame &gt; &amp;map, const <a class="el" href="classDirection.html">Direction</a>&lt; VolumeDim &gt; &amp;direction) noexcept</td></tr>
<tr class="memdesc:ga417a2e1563c807ebf515d4e9fa04d425"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the outward grid normal on a face of an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors. ">Element</a>.  <a href="#ga417a2e1563c807ebf515d4e9fa04d425">More...</a><br /></td></tr>
<tr class="separator:ga417a2e1563c807ebf515d4e9fa04d425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8cb42b1b2f7c90c5c86eaef2d2b97f7"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim, typename TargetFrame &gt; </td></tr>
<tr class="memitem:gad8cb42b1b2f7c90c5c86eaef2d2b97f7"><td class="memTemplItemLeft" align="right" valign="top">tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, TargetFrame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gad8cb42b1b2f7c90c5c86eaef2d2b97f7">unnormalized_face_normal</a> (const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim - 1 &gt; &amp;interface_mesh, const <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1Logical.html">Frame::Logical</a>, TargetFrame, VolumeDim &gt; &amp;map, const <a class="el" href="classDirection.html">Direction</a>&lt; VolumeDim &gt; &amp;direction) noexcept</td></tr>
<tr class="memdesc:gad8cb42b1b2f7c90c5c86eaef2d2b97f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the outward grid normal on a face of an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors. ">Element</a>.  <a href="#gad8cb42b1b2f7c90c5c86eaef2d2b97f7">More...</a><br /></td></tr>
<tr class="separator:gad8cb42b1b2f7c90c5c86eaef2d2b97f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga026c1241e187aa9ad0459c1720747887"><td class="memTemplParams" colspan="2"><a id="ga026c1241e187aa9ad0459c1720747887"></a>
template&lt;size_t VolumeDim, typename TagsList &gt; </td></tr>
<tr class="memitem:ga026c1241e187aa9ad0459c1720747887"><td class="memTemplItemLeft" align="right" valign="top">Variables&lt; TagsList &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga026c1241e187aa9ad0459c1720747887">orient_variables</a> (const Variables&lt; TagsList &gt; &amp;variables, const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &amp;extents, const OrientationMap&lt; VolumeDim &gt; &amp;orientation_of_neighbor) noexcept</td></tr>
<tr class="memdesc:ga026c1241e187aa9ad0459c1720747887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orient variables to the data-storage order of a neighbor element with the given orientation. <br /></td></tr>
<tr class="separator:ga026c1241e187aa9ad0459c1720747887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a76c153a789a2e992328e8662071515"><td class="memTemplParams" colspan="2"><a id="ga1a76c153a789a2e992328e8662071515"></a>
template&lt;size_t VolumeDim, typename TagsList &gt; </td></tr>
<tr class="memitem:ga1a76c153a789a2e992328e8662071515"><td class="memTemplItemLeft" align="right" valign="top">Variables&lt; TagsList &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga1a76c153a789a2e992328e8662071515">orient_variables_on_slice</a> (const Variables&lt; TagsList &gt; &amp;variables_on_slice, const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim - 1 &gt; &amp;slice_extents, const size_t sliced_dim, const OrientationMap&lt; VolumeDim &gt; &amp;orientation_of_neighbor) noexcept</td></tr>
<tr class="memdesc:ga1a76c153a789a2e992328e8662071515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orient variables to the data-storage order of a neighbor element with the given orientation. <br /></td></tr>
<tr class="separator:ga1a76c153a789a2e992328e8662071515"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The building blocks used to describe the computational domain. </p>
<h3>Description</h3>
<p>The VolumeDim-dimensional computational <a class="el" href="classDomain.html" title="A wrapper around a vector of Blocks that represent the computational domain. ">Domain</a> is constructed from a set of non-overlapping <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a>s. Each <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a> is a distorted VolumeDim-dimensional hypercube. Each codimension-1 boundary of a <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a> is either part of the external boundary of the computational domain, or is identical to a boundary of one other <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a>. Each <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a> is subdivided into one or more <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors. ">Element</a>s that may be changed dynamically if AMR is enabled. </p>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga6874579f1400ff7d0d77cbfa978289e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6874579f1400ff7d0d77cbfa978289e2">&#9670;&nbsp;</a></span>Flag</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__ComputationalDomainGroup.html#ga6874579f1400ff7d0d77cbfa978289e2">amr::Flag</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flags that represent decisions about mesh refinement. </p>
<p>In order to support anisotropic mesh refinement, a flag is specified for each dimension. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga6874579f1400ff7d0d77cbfa978289e2aec0fc0100c4fc1ce4eea230c3dc10360"></a>Undefined&#160;</td><td class="fielddoc"><p>used to initialize flags before a decision is made </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6874579f1400ff7d0d77cbfa978289e2aa286d9991c6a547ae25a5f5216164b8f"></a>Join&#160;</td><td class="fielddoc"><p>join the sibling of an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors. ">Element</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6874579f1400ff7d0d77cbfa978289e2ae566bdf06d954aec108ff063196a4147"></a>DecreaseResolution&#160;</td><td class="fielddoc"><p>decrease number of points in an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors. ">Element</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6874579f1400ff7d0d77cbfa978289e2a71b7f3fcd4098ebf8a3b387579d90dd7"></a>DoNothing&#160;</td><td class="fielddoc"><p>stay the same </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6874579f1400ff7d0d77cbfa978289e2a1f8c283304e4a6a17283ca12b9868273"></a>IncreaseResolution&#160;</td><td class="fielddoc"><p>increase number of points in an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors. ">Element</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6874579f1400ff7d0d77cbfa978289e2a8a9e64d86ed12ad40de129bc7f4683b2"></a>Split&#160;</td><td class="fielddoc"><p>split the <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors. ">Element</a> into two smaller elements </p>
</td></tr>
</table>

</div>
</div>
<a id="gac672a529d9aaa6a948b8b7eb6ec9b528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac672a529d9aaa6a948b8b7eb6ec9b528">&#9670;&nbsp;</a></span>ShellWedges</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__ComputationalDomainGroup.html#gac672a529d9aaa6a948b8b7eb6ec9b528">ShellWedges</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of wedges to include in the Shell domain. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggac672a529d9aaa6a948b8b7eb6ec9b528ab1c94ca2fbc3e78fc30069c8d0f01680"></a>All&#160;</td><td class="fielddoc"><p>Use the entire shell. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac672a529d9aaa6a948b8b7eb6ec9b528ace553534ea34f25db4b4a8b5bd29cf45"></a>FourOnEquator&#160;</td><td class="fielddoc"><p>Use only the four equatorial wedges. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac672a529d9aaa6a948b8b7eb6ec9b528ae9d8dbfbf81de7cf729066f677661edb"></a>OneAlongMinusX&#160;</td><td class="fielddoc"><p>Use only the single wedge along -x. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga8c0137d7160ad71b6ed265c53c99ed00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c0137d7160ad71b6ed265c53c99ed00">&#9670;&nbsp;</a></span>Side</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__ComputationalDomainGroup.html#ga8c0137d7160ad71b6ed265c53c99ed00">Side</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A label for the side of a manifold. </p>
<p>Lower and Upper are with respect to the logical coordinate whose axis is normal to the side, i.e. beyond the Upper (Lower) side, the logical coordinate is increasing (decreasing). </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga10f47cbc5864be98847fcd07355e3c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10f47cbc5864be98847fcd07355e3c4b">&#9670;&nbsp;</a></span>block_logical_coordinates()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim, typename Frame &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto block_logical_coordinates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDomain.html">Domain</a>&lt; Dim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; boost::optional&lt; <a class="el" href="structIdPair.html">IdPair</a>&lt; <a class="el" href="classdomain_1_1BlockId.html">domain::BlockId</a>, tnsr::I&lt; double, Dim, typename ::<a class="el" href="structFrame_1_1Logical.html">Frame::Logical</a> &gt;&gt;&gt;&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the block logical coordinates and the containing <code>BlockId</code> of a set of points, given coordinates in the <code><a class="el" href="namespaceFrame.html" title="Indicates the Frame that a TensorIndexType is in. ">Frame</a></code> frame. </p>
<h3>Details</h3>
<p>Returns a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;boost::optional&lt;IdPair&lt;BlockId,coords&gt;&gt;&gt;, where the vector runs over the points and is indexed in the same order as the input coordinates <code>x</code>. For each point, the <code><a class="el" href="structIdPair.html" title="A data structure that contains an ID and data associated with that ID. ">IdPair</a></code> holds the block logical coords of that point and the <code>BlockId</code> of the <code><a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a></code> that contains that point. The boost::optional is empty if the point is not in any <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a>. If a point is on a shared boundary of two or more <code><a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a></code>s, it is returned only once, and is considered to belong to the <code><a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a></code> with the smaller <code>BlockId</code>. </p>

</div>
</div>
<a id="gaa76c0e8c51614f3393118e403ed35a5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa76c0e8c51614f3393118e403ed35a5f">&#9670;&nbsp;</a></span>corners_for_biradially_layered_domains()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;<a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;size_t, 8&gt; &gt; corners_for_biradially_layered_domains </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>number_of_radial_layers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>number_of_biradial_layers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_central_block_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_central_block_rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, 8 &gt; &amp;&#160;</td>
          <td class="paramname"><em>central_block_corners_lhs</em> = <code>{&#160;{1,&#160;2,&#160;3,&#160;4,&#160;5,&#160;6,&#160;7,&#160;8}}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The corners for a domain with biradial layers. </p>
<p>Generates the corners for a BBH-like <a class="el" href="classDomain.html" title="A wrapper around a vector of Blocks that represent the computational domain. ">Domain</a> which is made of one or more layers of Blocks fully enveloping two interior volumes. The <code>number_of_radial_layers</code> gives the number of layers that fully envelop each interior volume with six Blocks each. The <code>number_of_biradial_layers</code> gives the number of layers that fully envelop both volumes at once, using ten Blocks per layer as opposed to six. The <code>central_block_corners_lhs</code> are used as seed values to generate the corners for the surrounding Blocks. </p>

</div>
</div>
<a id="ga18526a75399d20dfb670b233fa55cff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18526a75399d20dfb670b233fa55cff8">&#9670;&nbsp;</a></span>corners_for_radially_layered_domains()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;<a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;size_t, 8&gt; &gt; corners_for_radially_layered_domains </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>number_of_layers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_central_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, 8 &gt; &amp;&#160;</td>
          <td class="paramname"><em>central_block_corners</em> = <code>{{1,&#160;2,&#160;3,&#160;4,&#160;5,&#160;6,&#160;7,&#160;8}}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ComputationalDomainGroup.html#gac672a529d9aaa6a948b8b7eb6ec9b528">ShellWedges</a>&#160;</td>
          <td class="paramname"><em>which_wedges</em> = <code><a class="el" href="group__ComputationalDomainGroup.html#ggac672a529d9aaa6a948b8b7eb6ec9b528ab1c94ca2fbc3e78fc30069c8d0f01680">ShellWedges::All</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The corners for a domain with radial layers. </p>
<p>Generates the corners for a <a class="el" href="classDomain.html" title="A wrapper around a vector of Blocks that represent the computational domain. ">Domain</a> which is made of one or more layers of Blocks fully enveloping an interior volume, e.g. Shell or Sphere. The <code>number_of_layers</code> specifies how many of these layers of Blocks to have in the final domain. <code>include_central_block</code> is set to <code>true</code> in Sphere, where the interior volume is filled with a central <a class="el" href="classBlock.html" title="A Block&lt;VolumeDim&gt; is a region of a VolumeDim-dimensional computational domain that defines the root ...">Block</a>, and <code>false</code> in Shell, where the interior volume is left empty. The <code>central_block_corners</code> are used as seed values to generate the corners for the surrounding Blocks. </p>

</div>
</div>
<a id="ga18341ca86191b511f92daf2d8c69302c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18341ca86191b511f92daf2d8c69302c">&#9670;&nbsp;</a></span>corners_for_rectilinear_domains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto corners_for_rectilinear_domains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>domain_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>block_indices_to_exclude</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="group__ConstantExpressionsGroup.html#ga6c01ded3973bb4b9973e5381c32c0807">two_to_the</a>(VolumeDim)&gt;&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The corners for a rectilinear domain made of n-cubes. </p>
<p>The <code>domain_extents</code> argument holds the number of blocks to have in each dimension. The blocks all have aligned orientations by construction. The <code>block_indices_to_exclude</code> argument allows the user to selectively exclude blocks from the resulting domain. This allows for the creation of non-trivial shapes such as the net for a tesseract. </p>

</div>
</div>
<a id="gab6b39332c0ebaf70aa94de13661b2e13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6b39332c0ebaf70aa94de13661b2e13">&#9670;&nbsp;</a></span>desired_refinement_levels_of_neighbor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, VolumeDim &gt; amr::desired_refinement_levels_of_neighbor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElementId.html">ElementId</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>neighbor_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="group__ComputationalDomainGroup.html#ga6874579f1400ff7d0d77cbfa978289e2">amr::Flag</a>, VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>neighbor_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OrientationMap&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>orientation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the desired refinement level of a neighboring <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors. ">Element</a> with <a class="el" href="classElementId.html" title="An ElementId uniquely labels an Element. It is constructed from the BlockId of the Block to which the...">ElementId</a> <code>neighbor_id</code> given its desired <a class="el" href="group__ComputationalDomainGroup.html#ga6874579f1400ff7d0d77cbfa978289e2" title="Flags that represent decisions about mesh refinement. ">amr::Flag</a>s <code>neighbor_flags</code> taking into account the OrientationMap <code>orientation</code> of the neighbor. </p>
<h3>Details</h3>
<p>The OrientationMap <code>orientation</code> is that from the <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors. ">Element</a> that has a neighbor with <a class="el" href="classElementId.html" title="An ElementId uniquely labels an Element. It is constructed from the BlockId of the Block to which the...">ElementId</a> <code>neighbor_id</code> </p>

</div>
</div>
<a id="ga8c80443a66a28ba3cd542cf5f2d223c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c80443a66a28ba3cd542cf5f2d223c5">&#9670;&nbsp;</a></span>discrete_rotation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;size_t, <a class="el" href="group__ConstantExpressionsGroup.html#ga6c01ded3973bb4b9973e5381c32c0807">two_to_the</a>(VolumeDim)&gt; discrete_rotation </td>
          <td>(</td>
          <td class="paramtype">const OrientationMap&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>orientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="group__ConstantExpressionsGroup.html#ga6c01ded3973bb4b9973e5381c32c0807">two_to_the</a>(VolumeDim)&gt; &amp;&#160;</td>
          <td class="paramname"><em>corners_of_aligned</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Permutes the corner numbers of an n-cube. </p>
<p>Returns the correct ordering of global corner numbers for a rotated block in an otherwise aligned edifice of blocks, given the OrientationMap a block aligned with the edifice has relative to this one, and given the corner numbering the rotated block would have if it were aligned. This is useful in creating domains for testing purposes, e.g. RotatedIntervals, RotatedRectangles, and RotatedBricks. </p>

</div>
</div>
<a id="ga11187dd6e2dcf301fceabe0e4e4260fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11187dd6e2dcf301fceabe0e4e4260fa">&#9670;&nbsp;</a></span>element_logical_coordinates()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto element_logical_coordinates </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>element_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; boost::optional&lt; <a class="el" href="structIdPair.html">IdPair</a>&lt; <a class="el" href="classdomain_1_1BlockId.html">domain::BlockId</a>, tnsr::I&lt; double, Dim, typename <a class="el" href="structFrame_1_1Logical.html">Frame::Logical</a> &gt;&gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>block_coord_holders</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt;, <a class="el" href="structElementLogicalCoordHolder.html">ElementLogicalCoordHolder</a>&lt; Dim &gt;&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a set of points in block logical coordinates and their <code>BlockIds</code>, as returned from the function <code>block_logical_coordinates</code>, determines which <code><a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors. ">Element</a></code>s in a list of <code><a class="el" href="classElementId.html" title="An ElementId uniquely labels an Element. It is constructed from the BlockId of the Block to which the...">ElementId</a></code>s contains each point, and determines the element logical coordinates of each point. </p>
<h3>Details</h3>
<p>Returns a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a> from <code><a class="el" href="classElementId.html" title="An ElementId uniquely labels an Element. It is constructed from the BlockId of the Block to which the...">ElementId</a></code>s to <code><a class="el" href="structElementLogicalCoordHolder.html" title="Holds element logical coordinates of an arbitrary set of points on a single Element. The arbitrary set of points is assumed to be a subset of a larger set of points spanning multiple Elements, and this class holds offsets that index into that larger set of points. ">ElementLogicalCoordHolder</a></code>s. It is expected that only a subset of the points will be found in the given <code><a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors. ">Element</a></code>s. If a point is on a shared boundary of two or more <code><a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors. ">Element</a></code>s, it will be returned only once, and will be considered to belong to the first <code><a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors. ">Element</a></code> in the list of <code><a class="el" href="classElementId.html" title="An ElementId uniquely labels an Element. It is constructed from the BlockId of the Block to which the...">ElementId</a></code>s. </p>

</div>
</div>
<a id="ga86534fcfbcabd6acc079b6fc38cdfbea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86534fcfbcabd6acc079b6fc38cdfbea">&#9670;&nbsp;</a></span>frustum_coordinate_maps()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetFrame &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto frustum_coordinate_maps </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>length_inner_cube</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>length_outer_cube</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_equiangular_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>origin_preimage</em> = <code>{{0.0,&#160;0.0,&#160;0.0}}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>projective_scale_factor</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1Logical.html">Frame::Logical</a>, TargetFrame, 3 &gt;&gt;&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>These are the ten Frustums used in the DomainCreators for binary compact objects. The Frustums partition the volume defined by two bounding surfaces: The inner surface is the surface of the two joined inner cubes enveloping the two compact objects, while the outer is the surface of the outer cube. The cubes enveloping the two Shells each have a side length of <code>length_inner_cube</code>. The outer cube has a side length of <code>length_outer_cube</code>. <code>origin_preimage</code> is a parameter that moves the center of the two joined inner cubes away from the origin and to <code>-origin_preimage</code>. <code>projective_scale_factor</code> acts to change the gridpoint distribution in the radial direction. </p>
<dl class="section see"><dt>See also</dt><dd>Frustum for details. </dd></dl>

</div>
</div>
<a id="gac857ec0446d088d1d17cf96376ba8e3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac857ec0446d088d1d17cf96376ba8e3c">&#9670;&nbsp;</a></span>interface_logical_coordinates()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tnsr::I&lt;<a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, <a class="el" href="structFrame_1_1Logical.html">Frame::Logical</a>&gt; interface_logical_coordinates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDirection.html">Direction</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the logical coordinates on a face of an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors. ">Element</a>. </p>
<p><em>Returns:</em> logical-frame vector holding coordinates</p>
<h3>Example</h3>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code" href="classMesh.html">Mesh&lt;2&gt;</a> mesh_3d_zbdry{</div><div class="line">      {{5, 3}}, Spectral::Basis::Legendre, Spectral::Quadrature::GaussLobatto};</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> x_3d_lb_zeta = map_3d(</div><div class="line">      <a class="code" href="group__ComputationalDomainGroup.html#gac857ec0446d088d1d17cf96376ba8e3c">interface_logical_coordinates</a>(mesh_3d_zbdry, <a class="code" href="classDirection.html">Direction&lt;3&gt;::lower_zeta</a>()));</div></div><!-- fragment -->
</div>
</div>
<a id="gae78010c7660148ca595b42d17b38936a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae78010c7660148ca595b42d17b38936a">&#9670;&nbsp;</a></span>logical_coordinates()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tnsr::I&lt;<a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, <a class="el" href="structFrame_1_1Logical.html">Frame::Logical</a>&gt; logical_coordinates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the logical coordinates in an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors. ">Element</a>. </p>
<h3>Details</h3>
<p>The logical coordinates are the collocation points associated to the spectral basis functions and quadrature of the <code>mesh</code>.</p>
<p><em>Returns:</em> logical-frame vector holding coordinates</p>
<h3>Example</h3>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code" href="classMesh.html">Mesh&lt;3&gt;</a> mesh_3d{{{5, 3, 2}},</div><div class="line">                        Spectral::Basis::Legendre,</div><div class="line">                        Spectral::Quadrature::GaussLobatto};</div><div class="line"></div><div class="line">  <span class="keyword">const</span> CoordinateMaps::Affine x_map{-1.0, 1.0, -3.0, 7.0};</div><div class="line">  <span class="keyword">const</span> CoordinateMaps::Affine y_map{-1.0, 1.0, -13.0, 47.0};</div><div class="line">  <span class="keyword">const</span> CoordinateMaps::Affine z_map{-1.0, 1.0, -32.0, 74.0};</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> map_3d = make_coordinate_map&lt;Frame::Logical, Frame::Grid&gt;(</div><div class="line">      Affine3d{x_map, y_map, z_map});</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> x_3d = map_3d(<a class="code" href="group__ComputationalDomainGroup.html#gae78010c7660148ca595b42d17b38936a">logical_coordinates</a>(mesh_3d));</div></div><!-- fragment -->
</div>
</div>
<a id="ga2fa6f4a3bbb32cae7c59d29c519ce4a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2fa6f4a3bbb32cae7c59d29c519ce4a3">&#9670;&nbsp;</a></span>maps_for_rectilinear_domains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetFrame , size_t VolumeDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto maps_for_rectilinear_domains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>domain_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt;, VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>block_demarcations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>block_indices_to_exclude</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; OrientationMap&lt; VolumeDim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>orientations_of_all_blocks</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_equiangular_map</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1Logical.html">Frame::Logical</a>, TargetFrame, VolumeDim &gt;&gt;&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The CoordinateMaps for a rectilinear domain of n-cubes. </p>
<p>Allows for both Affine and Equiangular maps. </p>

</div>
</div>
<a id="gafa8cb44daebc8f9e080718961530be89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa8cb44daebc8f9e080718961530be89">&#9670;&nbsp;</a></span>maximum_number_of_neighbors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t maximum_number_of_neighbors </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum number of neighbors an element can have in <code>dim</code> dimensions. </p>
<dl class="section note"><dt>Note</dt><dd>Assumes a maximum 2-to-1 refinement between two adjacent Elements. </dd></dl>

</div>
</div>
<a id="ga45ff23a83bb3bab32bd30a13bc9a41a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45ff23a83bb3bab32bd30a13bc9a41a0">&#9670;&nbsp;</a></span>maximum_number_of_neighbors_per_direction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t maximum_number_of_neighbors_per_direction </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum number of neighbors in each direction an element can have in <code>dim</code> dimensions. </p>
<dl class="section note"><dt>Note</dt><dd>Assumes a maximum 2-to-1 refinement between two adjacent Elements. </dd></dl>

</div>
</div>
<a id="gafc2a358648d3b5b08419d433e9e0417c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc2a358648d3b5b08419d433e9e0417c">&#9670;&nbsp;</a></span>rectilinear_domain()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim, typename TargetFrame &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDomain.html">Domain</a>&lt;VolumeDim, TargetFrame&gt; rectilinear_domain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>domain_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt;, VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>block_demarcations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>block_indices_to_exclude</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; OrientationMap&lt; VolumeDim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>orientations_of_all_blocks</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; bool, VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dimension_is_periodic</em> = <code><a class="el" href="group__UtilitiesGroup.html#gaea51ad2c5ef8f8f99279545e1389d056">make_array</a>&lt;&#160;VolumeDim&#160;&gt;(false)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="structPairOfFaces.html">PairOfFaces</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>identifications</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_equiangular_map</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a rectilinear <a class="el" href="classDomain.html" title="A wrapper around a vector of Blocks that represent the computational domain. ">Domain</a> of multicubes. </p>
<h3>Details</h3>
<p>Useful for constructing domains for testing non-trivially connected rectilinear domains made up of cubes. We refer to a domain of this type as an edifice. The <code>domain_extents</code> provides the size (in the number of blocks) of the initial aligned edifice to construct. The <code>block_indices_to_exclude</code> parameter is used in refining the shape of the edifice from a cube to sometime more non-trivial, such as an L-shape or the net of a tesseract. The <code>block_demarcations</code> and <code>use_equiangular_map</code> parameters determine the CoordinateMaps to be used. <code>orientations_of_all_blocks</code> contains the OrientationMap of the edifice relative to each block.</p>
<p>The <code>identifications</code> parameter is used when identifying the faces of blocks in an edifice. This is used to identify the 1D boundaries in the 2D net for a 3D cube to construct a domain with topology S2. Note: If the user wishes to rotate the blocks as well as manually identify their faces, the user must provide the <a class="el" href="structPairOfFaces.html" title="Each member in PairOfFaces holds the global corner ids of a block face. PairOfFaces is used in settin...">PairOfFaces</a> corresponding to the rotated corners. </p>

</div>
</div>
<a id="ga1e9f4861faff254ef3ceefcd7e5dabac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e9f4861faff254ef3ceefcd7e5dabac">&#9670;&nbsp;</a></span>size_of_element()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;double, VolumeDim&gt; size_of_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>inertial_coords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the inertial-coordinate size of an element along each of its logical directions. </p>
<p>For each logical direction, compute the mean position (in inertial coordinates) of the element's lower and upper faces in that direction. This is done by simply averaging the coordinates of the face grid points. The size of the element along this logical direction is then the distance between the mean positions of the lower and upper faces. Note that for curved elements, this is an approximate measurement of size.</p>
<h3>Details</h3>
<p>Because this quantity is defined in terms of specific coordinates, it is not well represented by a <code>Tensor</code>, so we use a <code><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a></code>. </p>

</div>
</div>
<a id="ga417a2e1563c807ebf515d4e9fa04d425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga417a2e1563c807ebf515d4e9fa04d425">&#9670;&nbsp;</a></span>unnormalized_face_normal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim, typename TargetFrame &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tnsr::i&lt;<a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, TargetFrame&gt; unnormalized_face_normal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>interface_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classElementMap.html">ElementMap</a>&lt; VolumeDim, TargetFrame &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDirection.html">Direction</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the outward grid normal on a face of an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors. ">Element</a>. </p>
<p><em>Returns:</em> outward grid-frame one-form holding the normal</p>
<h3>Details</h3>
<p>Computes the grid-frame normal by taking the logical-frame unit one-form in the given <a class="el" href="classDirection.html" title="A particular Side along a particular coordinate Axis. ">Direction</a> and mapping it to the grid frame with the given map.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code" href="classMesh.html">Mesh&lt;0&gt;</a> mesh_0d;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> map_1d = make_coordinate_map&lt;Frame::Logical, Frame::Grid&gt;(</div><div class="line">      CoordinateMaps::Affine(-1.0, 1.0, -3.0, 7.0));</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> normal_1d_lower =</div><div class="line">      <a class="code" href="group__ComputationalDomainGroup.html#ga417a2e1563c807ebf515d4e9fa04d425">unnormalized_face_normal</a>(mesh_0d, map_1d, <a class="code" href="classDirection.html">Direction&lt;1&gt;::lower_xi</a>());</div></div><!-- fragment -->
</div>
</div>
<a id="gad8cb42b1b2f7c90c5c86eaef2d2b97f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8cb42b1b2f7c90c5c86eaef2d2b97f7">&#9670;&nbsp;</a></span>unnormalized_face_normal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim, typename TargetFrame &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tnsr::i&lt;<a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, TargetFrame&gt; unnormalized_face_normal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>interface_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1Logical.html">Frame::Logical</a>, TargetFrame, VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDirection.html">Direction</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the outward grid normal on a face of an <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors. ">Element</a>. </p>
<p><em>Returns:</em> outward grid-frame one-form holding the normal</p>
<h3>Details</h3>
<p>Computes the grid-frame normal by taking the logical-frame unit one-form in the given <a class="el" href="classDirection.html" title="A particular Side along a particular coordinate Axis. ">Direction</a> and mapping it to the grid frame with the given map.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code" href="classMesh.html">Mesh&lt;0&gt;</a> mesh_0d;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> map_1d = make_coordinate_map&lt;Frame::Logical, Frame::Grid&gt;(</div><div class="line">      CoordinateMaps::Affine(-1.0, 1.0, -3.0, 7.0));</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> normal_1d_lower =</div><div class="line">      <a class="code" href="group__ComputationalDomainGroup.html#ga417a2e1563c807ebf515d4e9fa04d425">unnormalized_face_normal</a>(mesh_0d, map_1d, <a class="code" href="classDirection.html">Direction&lt;1&gt;::lower_xi</a>());</div></div><!-- fragment -->
</div>
</div>
<a id="ga0adec4b3b909be2df0e6f9ef4d5615f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0adec4b3b909be2df0e6f9ef4d5615f1">&#9670;&nbsp;</a></span>update_amr_decision()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool amr::update_amr_decision </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="group__ComputationalDomainGroup.html#ga6874579f1400ff7d0d77cbfa978289e2">amr::Flag</a>, VolumeDim &gt; *&gt;&#160;</td>
          <td class="paramname"><em>my_current_amr_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classElementId.html">ElementId</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>neighbor_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="group__ComputationalDomainGroup.html#ga6874579f1400ff7d0d77cbfa978289e2">amr::Flag</a>, VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>neighbor_amr_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the AMR decisions <code>my_current_amr_flags</code> of the <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors. ">Element</a> <code>element</code> based on the AMR decisions <code>neighbor_amr_flags</code> of a neighbor <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors. ">Element</a> with <a class="el" href="classElementId.html" title="An ElementId uniquely labels an Element. It is constructed from the BlockId of the Block to which the...">ElementId</a> <code>neighbor_id</code>. </p>
<h3>Details</h3>
<p>This function is called by each element when it receives the AMR decisions of one of its neighbors. If any of its flags are updated, the element should send its new decisions to each of its neighbors. The following changes are made to the current flags of the element:</p><ul>
<li>If the neighbor wants to be two or more refinement levels higher than the element, the flag is updated to bring the element to within one level</li>
<li>If the element wants to join, and the neighbor is a potential sibling but wants to be at a different refinement level in any dimension, the flag is updated to not do h-refinement.</li>
</ul>
<p><em>Returns:</em> true if any flag is changed</p>
<dl class="section note"><dt>Note</dt><dd>Modifies <code>my_current_amr_flags</code> which are the AMR decisions of <code>element</code>. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
&copy; Copyright 2017 - 2019
<a href="https://black-holes.org">SXS Collaboration</a>,
<a href="LICENSE.txt" target="_blank">
<span class="hidden-xs">Distributed under the</span>
MIT License</a>
</small></address>
</body>
</html>
