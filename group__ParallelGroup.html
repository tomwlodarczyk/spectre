<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.8.13"/>
    <style>
        /*!
         * IE10 viewport hack for Surface/desktop Windows 8 bug
         * Copyright 2014-2015 Twitter, Inc.
         * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
         */
        @-webkit-viewport { width: device-width; }
        @-moz-viewport    { width: device-width; }
        @-ms-viewport     { width: device-width; }
        @-o-viewport      { width: device-width; }
        @viewport         { width: device-width; }
      </style>
  <title>SpECTRE: Parallelization</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js", "color.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
MathJax.Hub.Config({
    TeX: { equationNumbers: { autoNumber: "AMS" } }
});
MathJax.Hub.Config({
    tex2jax: {inlineMath: [['^^','^^'], ['\\(', '\\)']]}
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="bootstrap.min.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="popper.min.js"></script>
  <script type="text/javascript" src="bootstrap.min.js"></script>
  <script type="text/javascript" src="spectre.js"></script>
  </head>
  <body>
  <div id="top" class="navbar-fixed-top"><!-- do not remove this div, it is closed by doxygen! -->
  <!-- BEGIN TITLEAREA -->
  <div id="titlearea">
  <script type="text/javascript">
  var searchBox = new SearchBox("searchBox", "search",false,'Search');
  </script>
  <div id="main-nav">
    <ul class="sm sm-dox" id="main-menu">
      <li>
      <a href="index.html">
      SpECTRE &#160;
        <span id="projectnumber">v0.0.0</span>
      </a>
      </li>
      <li class="dropdown">
        <a class="dropdown-toggle" data-toggle="dropdown" href="#" id="selected">
          <span id="selected">
            <i class="octicon octicon-book"></i><span>Documentation</span>
          </span>
          <span class="caret"></span>
        </a>
        <ul class="dropdown-menu">
          <li style="min-width: 135px;">
            <a href="index.html">
            <i class="octicon octicon-book"></i><span>Introduction</span></a>
          </li>
          <li style="min-width: 135px;">
            <a href="installation.html">
              <i class="octicon octicon-desktop-download"></i><span>Installation</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="tutorials.html">
              <i class="octicon octicon-mortar-board"></i><span>User Tutorials</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="dev_guide.html">
              <i class="octicon octicon-gist-secret"></i><span>Dev Guide</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="code_of_conduct.html">
              <i class="octicon octicon-comment-discussion"></i><span>Code of Conduct</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="contributing_to_spectre.html">
              <i class="octicon octicon-git-pull-request"></i><span>Contributing Guide</span>
            </a>
          </li>
        </ul>
      </li>
      <li class="dropdown">
        <a class="dropdown-toggle" data-toggle="dropdown" href="#" id="selected">
          <span id="selected">
            <i class="octicon octicon-code"></i>
              <span>Code Reference</span>
          </span>
          <span class="caret"></span>
        </a>
        <ul class="dropdown-menu">
          <li style="min-width: 130px;">
            <a href="modules.html">
              <i class="octicon octicon-code"></i>
              <span>Topics</span>
            </a>
          </li>
          <li style="min-width: 130px;">
            <a href="namespaces.html">
              <i class="octicon octicon-gist"></i>
              <span>Namespaces</span>
            </a>
          </li>
        </ul>
      </li>
      <li>
        <a href="files.html">
          <i class="octicon octicon-file-directory"></i><span>Files</span>
        </a>
      </li>
      <li>
        <a href="citelist.html">
          <i class="octicon octicon-file-text"></i><span>Bibliography</span>
        </a>
      </li>
      <li>
        <a href="https://github.com/sxs-collaboration/spectre" target="_blank">
          <i class="octicon octicon-mark-github"></i><span>View on GitHub</span>
        </a>
      </li>
      <!--The Search <li> is added by doxygen later-->
    </ul>
  </div><!-- main-nav -->
  </div><!-- titlearea -->
  <!-- window showing the filter options -->
  <div id="MSearchSelectWindow"  style="position: fixed;"
       onmouseover="return searchBox.OnSearchSelectShow()"
       onmouseout="return searchBox.OnSearchSelectHide()"
       onkeydown="return searchBox.OnSearchSelectKey(event)">
  </div>
  <!-- iframe showing the search results (closed by default) -->
  <div id="MSearchResultsWindow"  style="position: fixed;">
  <iframe src="javascript:void(0)" frameborder="0"
          name="MSearchResults" id="MSearchResults">
  </iframe>
  </div>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Parallelization</div>  </div>
</div><!--header-->
<div class="contents">

<p>Functions, classes and documentation related to parallelization and Charm++.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElementIndex.html">ElementIndex&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for indexing a Charm array by <a class="el" href="classElement.html" title="A spectral element with knowledge of its neighbors. ">Element</a>.  <a href="classElementIndex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel_1_1AlgorithmImpl_3_01ParallelComponent_00_01tmpl_1_1list_3_01PhaseDepActionListsPack_8_8_8_01_4_01_4.html">Parallel::AlgorithmImpl&lt; ParallelComponent, tmpl::list&lt; PhaseDepActionListsPack... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A distributed object (Charm++ Chare) that executes a series of Actions and is capable of sending and receiving data. Acts as an interface to Charm++.  <a href="classParallel_1_1AlgorithmImpl_3_01ParallelComponent_00_01tmpl_1_1list_3_01PhaseDepActionListsPack_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1ArrayIndex.html">Parallel::ArrayIndex&lt; Index &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The array index used for indexing Chare Arrays, mostly an implementation detail.  <a href="structParallel_1_1ArrayIndex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel_1_1ConstGlobalCache.html">Parallel::ConstGlobalCache&lt; Metavariables &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Charm++ chare that caches constant data once per Charm++ node.  <a href="classParallel_1_1ConstGlobalCache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1Tags_1_1ConstGlobalCache.html">Parallel::Tags::ConstGlobalCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag to retrieve the <code><a class="el" href="classParallel_1_1ConstGlobalCache.html" title="A Charm++ chare that caches constant data once per Charm++ node. ">Parallel::ConstGlobalCache</a></code> from the DataBox.  <a href="structParallel_1_1Tags_1_1ConstGlobalCache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1Tags_1_1FromConstGlobalCache.html">Parallel::Tags::FromConstGlobalCache&lt; CacheTag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag used to retrieve data from the <code><a class="el" href="classParallel_1_1ConstGlobalCache.html" title="A Charm++ chare that caches constant data once per Charm++ node. ">Parallel::ConstGlobalCache</a></code>. This is the recommended way for compute tags to retrieve data out of the global cache.  <a href="structParallel_1_1Tags_1_1FromConstGlobalCache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel_1_1Main.html">Parallel::Main&lt; Metavariables &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main function of a Charm++ executable. See <a href="group__ParallelGroup.html#details">the Parallelization documentation</a> for an overview of Metavariables, Phases, and parallel components.  <a href="classParallel_1_1Main.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1PhaseActions.html">Parallel::PhaseActions&lt; PhaseType, Phase, ActionsList &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of all the actions to be executed in the specified phase.  <a href="structParallel_1_1PhaseActions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1get__action__list__from__phase__dep__action__list.html">Parallel::get_action_list_from_phase_dep_action_list&lt; PhaseDepActionList &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Lazy) metafunction to get the action list from a <code><a class="el" href="structParallel_1_1PhaseActions.html" title="List of all the actions to be executed in the specified phase. ">PhaseActions</a></code>  <a href="structParallel_1_1get__action__list__from__phase__dep__action__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1get__phase__type__from__phase__dep__action__list.html">Parallel::get_phase_type_from_phase_dep_action_list&lt; PhaseDepActionList &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Lazy) metafunction to get the phase type from a <code><a class="el" href="structParallel_1_1PhaseActions.html" title="List of all the actions to be executed in the specified phase. ">PhaseActions</a></code>  <a href="structParallel_1_1get__phase__type__from__phase__dep__action__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1get__phase__from__phase__dep__action__list.html">Parallel::get_phase_from_phase_dep_action_list&lt; PhaseDepActionList &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Lazy) metafunction to get the phase as a <code><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::integral_constant</a></code> from a <code><a class="el" href="structParallel_1_1PhaseActions.html" title="List of all the actions to be executed in the specified phase. ">PhaseActions</a></code>  <a href="structParallel_1_1get__phase__from__phase__dep__action__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1ReductionDatum.html">Parallel::ReductionDatum&lt; T, InvokeCombine, InvokeFinal, InvokeFinalExtraArgsIndices &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The data to be reduced, and invokables to be called whenever two reduction messages are combined and after the reduction has been completed.  <a href="structParallel_1_1ReductionDatum.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1ReductionData_3_01ReductionDatum_3_01Ts_00_01InvokeCombines_00_01InvokeFinals_92b572618a1ebe21ccf137654ec822ac.html">Parallel::ReductionData&lt; ReductionDatum&lt; Ts, InvokeCombines, InvokeFinals, InvokeFinalExtraArgsIndices &gt;... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for reducing a possibly heterogeneous collection of types in a single reduction call.  <a href="structParallel_1_1ReductionData_3_01ReductionDatum_3_01Ts_00_01InvokeCombines_00_01InvokeFinals_92b572618a1ebe21ccf137654ec822ac.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1is__array__proxy.html">Parallel::is_array_proxy&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>T</code> is a Charm++ proxy for an array chare.  <a href="structParallel_1_1is__array__proxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1is__chare__proxy.html">Parallel::is_chare_proxy&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>T</code> is a Charm++ proxy for a chare.  <a href="structParallel_1_1is__chare__proxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1is__group__proxy.html">Parallel::is_group_proxy&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>T</code> is a Charm++ proxy for a group chare.  <a href="structParallel_1_1is__group__proxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1is__node__group__proxy.html">Parallel::is_node_group_proxy&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>T</code> is a Charm++ proxy for a node group chare.  <a href="structParallel_1_1is__node__group__proxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1is__bound__array.html">Parallel::is_bound_array&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>T</code> is a ParallelComponent for a Charm++ bound array.  <a href="structParallel_1_1is__bound__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1has__pup__member.html">Parallel::has_pup_member&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>T</code> has a <code>pup</code> member function.  <a href="structParallel_1_1has__pup__member.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel_1_1is__pupable.html">Parallel::is_pupable&lt; T, U &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if type <code>T</code> has operator| defined for Charm++ serialization.  <a href="structParallel_1_1is__pupable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga54770b986b9c522da6d651e1be125a03"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga54770b986b9c522da6d651e1be125a03">WRAPPED_PUPable_decl_template</a>(className)&#160;&#160;&#160;PUPable_decl_template(SINGLE_ARG(className))</td></tr>
<tr class="memdesc:ga54770b986b9c522da6d651e1be125a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark derived classes as serializable.  <a href="#ga54770b986b9c522da6d651e1be125a03">More...</a><br /></td></tr>
<tr class="separator:ga54770b986b9c522da6d651e1be125a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade9eecd27ecadb3501ddae591bf07db0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#gade9eecd27ecadb3501ddae591bf07db0">WRAPPED_PUPable_decl_base_template</a>(baseClassName,  className)&#160;&#160;&#160;PUPable_decl_base_template(SINGLE_ARG(baseClassName), SINGLE_ARG(className))</td></tr>
<tr class="memdesc:gade9eecd27ecadb3501ddae591bf07db0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark derived template classes as serializable.  <a href="#gade9eecd27ecadb3501ddae591bf07db0">More...</a><br /></td></tr>
<tr class="separator:gade9eecd27ecadb3501ddae591bf07db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gae918917e798cb6dd36a6cca9ede77616"><td class="memTemplParams" colspan="2"><a id="gae918917e798cb6dd36a6cca9ede77616"></a>
template&lt;class ActionsList &gt; </td></tr>
<tr class="memitem:gae918917e798cb6dd36a6cca9ede77616"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#gae918917e798cb6dd36a6cca9ede77616">Parallel::get_inbox_tags</a> = tmpl::remove_duplicates&lt; tmpl::join&lt; tmpl::transform&lt; ActionsList, detail::get_inbox_tags_from_action&lt; tmpl::_1 &gt; &gt;&gt; &gt;</td></tr>
<tr class="memdesc:gae918917e798cb6dd36a6cca9ede77616"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of Actions, get a list of the unique inbox tags. <br /></td></tr>
<tr class="separator:gae918917e798cb6dd36a6cca9ede77616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2c3e5b7084f5cb31c8c5cc7595349a6"><td class="memTemplParams" colspan="2"><a id="gab2c3e5b7084f5cb31c8c5cc7595349a6"></a>
template&lt;class ActionsList &gt; </td></tr>
<tr class="memitem:gab2c3e5b7084f5cb31c8c5cc7595349a6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#gab2c3e5b7084f5cb31c8c5cc7595349a6">Parallel::get_const_global_cache_tags_from_actions</a> = tmpl::remove_duplicates&lt; tmpl::join&lt; tmpl::transform&lt; ActionsList, detail::get_const_global_cache_tags_from_parallel_struct&lt; tmpl::_1 &gt; &gt;&gt; &gt;</td></tr>
<tr class="memdesc:gab2c3e5b7084f5cb31c8c5cc7595349a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of Actions, get a list of the unique tags specified in the actions' <code>const_global_cache_tags</code> aliases. <br /></td></tr>
<tr class="separator:gab2c3e5b7084f5cb31c8c5cc7595349a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03e3053314568ebf144ba895c04ead0e"><td class="memTemplParams" colspan="2"><a id="ga03e3053314568ebf144ba895c04ead0e"></a>
template&lt;typename Metavariables &gt; </td></tr>
<tr class="memitem:ga03e3053314568ebf144ba895c04ead0e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga03e3053314568ebf144ba895c04ead0e">Parallel::get_const_global_cache_tags</a> = tmpl::remove_duplicates&lt; tmpl::flatten&lt; tmpl::list&lt; typename detail::get_const_global_cache_tags_from_parallel_struct&lt; Metavariables &gt;::type, tmpl::transform&lt; typename Metavariables::component_list, detail::get_const_global_cache_tags_from_parallel_struct&lt; tmpl::_1 &gt; &gt;, tmpl::transform&lt; typename Metavariables::component_list, detail::get_const_global_cache_tags_from_pdal&lt; tmpl::_1 &gt; &gt;&gt; &gt;&gt;</td></tr>
<tr class="memdesc:ga03e3053314568ebf144ba895c04ead0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the metavariables, get a list of the unique tags that will specify the items in the <a class="el" href="classParallel_1_1ConstGlobalCache.html" title="A Charm++ chare that caches constant data once per Charm++ node. ">ConstGlobalCache</a>. <br /></td></tr>
<tr class="separator:ga03e3053314568ebf144ba895c04ead0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5fb42f8eaf4da2707e32ed37ecf4e66"><td class="memTemplParams" colspan="2"><a id="gac5fb42f8eaf4da2707e32ed37ecf4e66"></a>
template&lt;typename PhaseDepActionList &gt; </td></tr>
<tr class="memitem:gac5fb42f8eaf4da2707e32ed37ecf4e66"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#gac5fb42f8eaf4da2707e32ed37ecf4e66">Parallel::get_initialization_actions_list</a> = tmpl::flatten&lt; tmpl::transform&lt; PhaseDepActionList, detail::get_initialization_actions_list&lt; tmpl::_1 &gt; &gt;&gt;</td></tr>
<tr class="memdesc:gac5fb42f8eaf4da2707e32ed37ecf4e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the phase dependent action list, return the list of actions in the Initialization phase (or an empty list if the Initialization phase is absent from the phase dependent action list) <br /></td></tr>
<tr class="separator:gac5fb42f8eaf4da2707e32ed37ecf4e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e2e4c961e55eb461d66770393e4f45d"><td class="memTemplParams" colspan="2"><a id="ga1e2e4c961e55eb461d66770393e4f45d"></a>
template&lt;typename InitializationActionsList , typename AllocationTagsList  = tmpl::list&lt;&gt;&gt; </td></tr>
<tr class="memitem:ga1e2e4c961e55eb461d66770393e4f45d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga1e2e4c961e55eb461d66770393e4f45d">Parallel::get_initialization_tags</a> = tmpl::remove_duplicates&lt; tmpl::flatten&lt; tmpl::list&lt; AllocationTagsList, tmpl::transform&lt; InitializationActionsList, detail::get_initialization_tags_from_action&lt; tmpl::_1 &gt; &gt;&gt; &gt;&gt;</td></tr>
<tr class="memdesc:ga1e2e4c961e55eb461d66770393e4f45d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of initialization actions, and possibly a list of tags needed for allocation of an array component, returns a list of the unique initialization_tags for all the actions (and the allocate function). <br /></td></tr>
<tr class="separator:ga1e2e4c961e55eb461d66770393e4f45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fc2e63ea42550ab888291b78b3a0bb4"><td class="memTemplParams" colspan="2"><a id="ga5fc2e63ea42550ab888291b78b3a0bb4"></a>
template&lt;typename InitializationActionsList &gt; </td></tr>
<tr class="memitem:ga5fc2e63ea42550ab888291b78b3a0bb4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga5fc2e63ea42550ab888291b78b3a0bb4">Parallel::get_initialization_tags_to_keep</a> = tmpl::remove_duplicates&lt; tmpl::flatten&lt; tmpl::transform&lt; InitializationActionsList, detail::get_initialization_tags_to_keep_from_action&lt; tmpl::_1 &gt; &gt;&gt; &gt;</td></tr>
<tr class="memdesc:ga5fc2e63ea42550ab888291b78b3a0bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of initialization actions, returns a list of the unique initialization_tags_to_keep for all the actions. These are the tags that are not removed from the DataBox after initialization. <br /></td></tr>
<tr class="separator:ga5fc2e63ea42550ab888291b78b3a0bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac18444ea3dc0a8bec0e24127d426bdc0"><td class="memTemplParams" colspan="2"><a id="gac18444ea3dc0a8bec0e24127d426bdc0"></a>
template&lt;typename InitializationTagsList &gt; </td></tr>
<tr class="memitem:gac18444ea3dc0a8bec0e24127d426bdc0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#gac18444ea3dc0a8bec0e24127d426bdc0">Parallel::get_option_tags</a> = tmpl::remove_duplicates&lt; tmpl::flatten&lt; tmpl::transform&lt; InitializationTagsList, detail::get_option_tags_from_initialization_tag&lt; tmpl::_1 &gt; &gt;&gt; &gt;</td></tr>
<tr class="memdesc:gac18444ea3dc0a8bec0e24127d426bdc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of initialization tags, returns a list of the unique option tags required to construct them. <br /></td></tr>
<tr class="separator:gac18444ea3dc0a8bec0e24127d426bdc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaccc68e564135958d18110d2847dcc1b3"><td class="memItemLeft" align="right" valign="top"><a id="gaccc68e564135958d18110d2847dcc1b3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#gaccc68e564135958d18110d2847dcc1b3">Parallel::abort</a> (const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;message)</td></tr>
<tr class="memdesc:gaccc68e564135958d18110d2847dcc1b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abort the program with an error message. <br /></td></tr>
<tr class="separator:gaccc68e564135958d18110d2847dcc1b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ca2773484152df4d8897024a244b3c0"><td class="memItemLeft" align="right" valign="top"><a id="ga8ca2773484152df4d8897024a244b3c0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga8ca2773484152df4d8897024a244b3c0">Parallel::exit</a> ()</td></tr>
<tr class="memdesc:ga8ca2773484152df4d8897024a244b3c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exit the program normally. This should only be called once over all processors. <br /></td></tr>
<tr class="separator:ga8ca2773484152df4d8897024a244b3c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga537d2cc78336566826c93c49f82746a8"><td class="memItemLeft" align="right" valign="top"><a id="ga537d2cc78336566826c93c49f82746a8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga537d2cc78336566826c93c49f82746a8">Parallel::number_of_procs</a> ()</td></tr>
<tr class="memdesc:ga537d2cc78336566826c93c49f82746a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of processing elements. <br /></td></tr>
<tr class="separator:ga537d2cc78336566826c93c49f82746a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9537d2f88bafe61b07e0ceda735243ca"><td class="memItemLeft" align="right" valign="top"><a id="ga9537d2f88bafe61b07e0ceda735243ca"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga9537d2f88bafe61b07e0ceda735243ca">Parallel::my_proc</a> ()</td></tr>
<tr class="memdesc:ga9537d2f88bafe61b07e0ceda735243ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of my processing element. <br /></td></tr>
<tr class="separator:ga9537d2f88bafe61b07e0ceda735243ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf999b9700ece84fca6cb82bb1ee9f3f2"><td class="memItemLeft" align="right" valign="top"><a id="gaf999b9700ece84fca6cb82bb1ee9f3f2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#gaf999b9700ece84fca6cb82bb1ee9f3f2">Parallel::number_of_nodes</a> ()</td></tr>
<tr class="memdesc:gaf999b9700ece84fca6cb82bb1ee9f3f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of nodes. <br /></td></tr>
<tr class="separator:gaf999b9700ece84fca6cb82bb1ee9f3f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f24e1c6dfcfa4e9250a165973b1a524"><td class="memItemLeft" align="right" valign="top"><a id="ga9f24e1c6dfcfa4e9250a165973b1a524"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga9f24e1c6dfcfa4e9250a165973b1a524">Parallel::my_node</a> ()</td></tr>
<tr class="memdesc:ga9f24e1c6dfcfa4e9250a165973b1a524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of my node. <br /></td></tr>
<tr class="separator:ga9f24e1c6dfcfa4e9250a165973b1a524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9459395dbb2a65f0d0b0439387067a1"><td class="memItemLeft" align="right" valign="top"><a id="gab9459395dbb2a65f0d0b0439387067a1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#gab9459395dbb2a65f0d0b0439387067a1">Parallel::procs_on_node</a> (const int node_index)</td></tr>
<tr class="memdesc:gab9459395dbb2a65f0d0b0439387067a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of processing elements on the given node. <br /></td></tr>
<tr class="separator:gab9459395dbb2a65f0d0b0439387067a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0899b00614f1c47c6b32d1f83976a23b"><td class="memItemLeft" align="right" valign="top"><a id="ga0899b00614f1c47c6b32d1f83976a23b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga0899b00614f1c47c6b32d1f83976a23b">Parallel::my_local_rank</a> ()</td></tr>
<tr class="memdesc:ga0899b00614f1c47c6b32d1f83976a23b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The local index of my processing element on my node. This is in the interval 0, ..., procs_on_node(my_node()) - 1. <br /></td></tr>
<tr class="separator:ga0899b00614f1c47c6b32d1f83976a23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f2f2d9db4aca7b4f11370e1556b43a5"><td class="memItemLeft" align="right" valign="top"><a id="ga6f2f2d9db4aca7b4f11370e1556b43a5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga6f2f2d9db4aca7b4f11370e1556b43a5">Parallel::first_proc_on_node</a> (const int node_index)</td></tr>
<tr class="memdesc:ga6f2f2d9db4aca7b4f11370e1556b43a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of first processing element on the given node. <br /></td></tr>
<tr class="separator:ga6f2f2d9db4aca7b4f11370e1556b43a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga042f8935c6008898b980065058d0d8e2"><td class="memItemLeft" align="right" valign="top"><a id="ga042f8935c6008898b980065058d0d8e2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga042f8935c6008898b980065058d0d8e2">Parallel::node_of</a> (const int proc_index)</td></tr>
<tr class="memdesc:ga042f8935c6008898b980065058d0d8e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of the node for the given processing element. <br /></td></tr>
<tr class="separator:ga042f8935c6008898b980065058d0d8e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab13a71393339d7f35a3f802df360429b"><td class="memItemLeft" align="right" valign="top"><a id="gab13a71393339d7f35a3f802df360429b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#gab13a71393339d7f35a3f802df360429b">Parallel::local_rank_of</a> (const int proc_index)</td></tr>
<tr class="memdesc:gab13a71393339d7f35a3f802df360429b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The local index for the given processing element on its node. <br /></td></tr>
<tr class="separator:gab13a71393339d7f35a3f802df360429b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62feba0b73433140761dad9a3127b998"><td class="memItemLeft" align="right" valign="top"><a id="ga62feba0b73433140761dad9a3127b998"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga62feba0b73433140761dad9a3127b998">Parallel::wall_time</a> ()</td></tr>
<tr class="memdesc:ga62feba0b73433140761dad9a3127b998"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current wall time in seconds. <br /></td></tr>
<tr class="separator:ga62feba0b73433140761dad9a3127b998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88e5396473adcaffed3465a9333f72f4"><td class="memItemLeft" align="right" valign="top"><a id="ga88e5396473adcaffed3465a9333f72f4"></a>
CmiNodeLock&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga88e5396473adcaffed3465a9333f72f4">Parallel::create_lock</a> () noexcept</td></tr>
<tr class="memdesc:ga88e5396473adcaffed3465a9333f72f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a converse CmiNodeLock. <br /></td></tr>
<tr class="separator:ga88e5396473adcaffed3465a9333f72f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac77c46b622bbe8ff936adc7bf7bd178"><td class="memItemLeft" align="right" valign="top"><a id="gaac77c46b622bbe8ff936adc7bf7bd178"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#gaac77c46b622bbe8ff936adc7bf7bd178">Parallel::free_lock</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; CmiNodeLock *&gt; node_lock) noexcept</td></tr>
<tr class="memdesc:gaac77c46b622bbe8ff936adc7bf7bd178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a converse CmiNodeLock. Using the lock after free is undefined behavior. <br /></td></tr>
<tr class="separator:gaac77c46b622bbe8ff936adc7bf7bd178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0397ccb72cb4205f5dc83d6f60d47d0"><td class="memItemLeft" align="right" valign="top"><a id="gad0397ccb72cb4205f5dc83d6f60d47d0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#gad0397ccb72cb4205f5dc83d6f60d47d0">Parallel::lock</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; CmiNodeLock *&gt; node_lock) noexcept</td></tr>
<tr class="memdesc:gad0397ccb72cb4205f5dc83d6f60d47d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock a converse CmiNodeLock. <br /></td></tr>
<tr class="separator:gad0397ccb72cb4205f5dc83d6f60d47d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b5b8d712c472935e5c817e9ed723c25"><td class="memItemLeft" align="right" valign="top"><a id="ga8b5b8d712c472935e5c817e9ed723c25"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga8b5b8d712c472935e5c817e9ed723c25">Parallel::try_lock</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; CmiNodeLock *&gt; node_lock) noexcept</td></tr>
<tr class="memdesc:ga8b5b8d712c472935e5c817e9ed723c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the lock was successfully acquired and false if the lock is already acquired by another processor. <br /></td></tr>
<tr class="separator:ga8b5b8d712c472935e5c817e9ed723c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26e5eb4933e796cd454b67ac773836f9"><td class="memItemLeft" align="right" valign="top"><a id="ga26e5eb4933e796cd454b67ac773836f9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga26e5eb4933e796cd454b67ac773836f9">Parallel::unlock</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; CmiNodeLock *&gt; node_lock) noexcept</td></tr>
<tr class="memdesc:ga26e5eb4933e796cd454b67ac773836f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock a converse CmiNodeLock. <br /></td></tr>
<tr class="separator:ga26e5eb4933e796cd454b67ac773836f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5a94dcac624b1a393a976a462ae1700"><td class="memTemplParams" colspan="2"><a id="gaf5a94dcac624b1a393a976a462ae1700"></a>
template&lt;typename... Tags, typename... OptionTags&gt; </td></tr>
<tr class="memitem:gaf5a94dcac624b1a393a976a462ae1700"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple</a>&lt; Tags... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#gaf5a94dcac624b1a393a976a462ae1700">Parallel::create_from_options</a> (const <a class="el" href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple</a>&lt; OptionTags... &gt; &amp;options, tmpl::list&lt; Tags... &gt;) noexcept</td></tr>
<tr class="memdesc:gaf5a94dcac624b1a393a976a462ae1700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of tags and a tagged tuple containing items created from input options, return a tagged tuple of items constructed by calls to create_from_options for each tag in the list. <br /></td></tr>
<tr class="separator:gaf5a94dcac624b1a393a976a462ae1700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae21964b5d28608afd21ae090c1c4c073"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:gae21964b5d28608afd21ae090c1c4c073"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#gae21964b5d28608afd21ae090c1c4c073">Parallel::printf</a> (const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;format, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:gae21964b5d28608afd21ae090c1c4c073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print an atomic message to stdout with C printf usage.  <a href="group__ParallelGroup.html#gae21964b5d28608afd21ae090c1c4c073">More...</a><br /></td></tr>
<tr class="separator:gae21964b5d28608afd21ae090c1c4c073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8448205dbaf9741505bd30dfad2cadc"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:gaa8448205dbaf9741505bd30dfad2cadc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#gaa8448205dbaf9741505bd30dfad2cadc">Parallel::printf_error</a> (const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;format, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:gaa8448205dbaf9741505bd30dfad2cadc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print an atomic message to stderr with C printf usage.  <a href="group__ParallelGroup.html#gaa8448205dbaf9741505bd30dfad2cadc">More...</a><br /></td></tr>
<tr class="separator:gaa8448205dbaf9741505bd30dfad2cadc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54a41b362281ea1321a50c609f59cf7b"><td class="memTemplParams" colspan="2"><a id="ga54a41b362281ea1321a50c609f59cf7b"></a>
template&lt;class Action , class SenderProxy , class TargetProxy , class... Ts&gt; </td></tr>
<tr class="memitem:ga54a41b362281ea1321a50c609f59cf7b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga54a41b362281ea1321a50c609f59cf7b">Parallel::contribute_to_reduction</a> (ReductionData&lt; Ts... &gt; reduction_data, const SenderProxy &amp;sender_component, const TargetProxy &amp;target_component) noexcept</td></tr>
<tr class="memdesc:ga54a41b362281ea1321a50c609f59cf7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a reduction from the <code>sender_component</code> (typically your own parallel component) to the <code>target_component</code>, performing the <code>Action</code> upon receiving the reduction. <br /></td></tr>
<tr class="separator:ga54a41b362281ea1321a50c609f59cf7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf46b590510bd8fad34c7055079262707"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gaf46b590510bd8fad34c7055079262707"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; char &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#gaf46b590510bd8fad34c7055079262707">serialize</a> (const U &amp;obj)</td></tr>
<tr class="memdesc:gaf46b590510bd8fad34c7055079262707"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize an object using PUP.  <a href="#gaf46b590510bd8fad34c7055079262707">More...</a><br /></td></tr>
<tr class="separator:gaf46b590510bd8fad34c7055079262707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fb3864413e851ea6dcd1ffa319f2f25"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6fb3864413e851ea6dcd1ffa319f2f25"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga6fb3864413e851ea6dcd1ffa319f2f25">deserialize</a> (const void *const data)</td></tr>
<tr class="memdesc:ga6fb3864413e851ea6dcd1ffa319f2f25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize an object using PUP.  <a href="#ga6fb3864413e851ea6dcd1ffa319f2f25">More...</a><br /></td></tr>
<tr class="separator:ga6fb3864413e851ea6dcd1ffa319f2f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga267c8d6d5f2313bd05ed69f91485776f"><td class="memTemplParams" colspan="2">template&lt;typename ParallelComponentTag , typename Metavariables &gt; </td></tr>
<tr class="memitem:ga267c8d6d5f2313bd05ed69f91485776f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga267c8d6d5f2313bd05ed69f91485776f">Parallel::get_parallel_component</a> (<a class="el" href="classParallel_1_1ConstGlobalCache.html">ConstGlobalCache</a>&lt; Metavariables &gt; &amp;cache) noexcept -&gt; Parallel::proxy_from_parallel_component&lt; ConstGlobalCache_detail::get_component_if_mocked&lt; typename Metavariables::component_list, ParallelComponentTag &gt;&gt; &amp;</td></tr>
<tr class="memdesc:ga267c8d6d5f2313bd05ed69f91485776f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the Charm++ proxy associated with a ParallelComponent.  <a href="group__ParallelGroup.html#ga267c8d6d5f2313bd05ed69f91485776f">More...</a><br /></td></tr>
<tr class="separator:ga267c8d6d5f2313bd05ed69f91485776f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga992eab06d03182bf63eeeea8880fcf1f"><td class="memTemplParams" colspan="2">template&lt;typename ParallelComponentTag , typename Metavariables &gt; </td></tr>
<tr class="memitem:ga992eab06d03182bf63eeeea8880fcf1f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga992eab06d03182bf63eeeea8880fcf1f">Parallel::get_parallel_component</a> (const <a class="el" href="classParallel_1_1ConstGlobalCache.html">ConstGlobalCache</a>&lt; Metavariables &gt; &amp;cache) noexcept -&gt; const Parallel::proxy_from_parallel_component&lt; ConstGlobalCache_detail::get_component_if_mocked&lt; typename Metavariables::component_list, ParallelComponentTag &gt;&gt; &amp;</td></tr>
<tr class="memdesc:ga992eab06d03182bf63eeeea8880fcf1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the Charm++ proxy associated with a ParallelComponent.  <a href="group__ParallelGroup.html#ga992eab06d03182bf63eeeea8880fcf1f">More...</a><br /></td></tr>
<tr class="separator:ga992eab06d03182bf63eeeea8880fcf1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5650367ede7ee5b92720ed3636df24e2"><td class="memTemplParams" colspan="2">template&lt;typename ConstGlobalCacheTag , typename Metavariables &gt; </td></tr>
<tr class="memitem:ga5650367ede7ee5b92720ed3636df24e2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga5650367ede7ee5b92720ed3636df24e2">Parallel::get</a> (const <a class="el" href="classParallel_1_1ConstGlobalCache.html">ConstGlobalCache</a>&lt; Metavariables &gt; &amp;cache) noexcept -&gt; const ConstGlobalCache_detail::type_for_get&lt; ConstGlobalCacheTag, Metavariables &gt; &amp;</td></tr>
<tr class="memdesc:ga5650367ede7ee5b92720ed3636df24e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access data in the cache.  <a href="group__ParallelGroup.html#ga5650367ede7ee5b92720ed3636df24e2">More...</a><br /></td></tr>
<tr class="separator:ga5650367ede7ee5b92720ed3636df24e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac776b0d8511f6205734478df6adb2998"><td class="memTemplParams" colspan="2">template&lt;typename ReceiveTag , typename Proxy , typename ReceiveDataType , Requires&lt; detail::has_ckLocal_method&lt; std::decay_t&lt; Proxy &gt;&gt;::value &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:gac776b0d8511f6205734478df6adb2998"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#gac776b0d8511f6205734478df6adb2998">Parallel::receive_data</a> (Proxy &amp;&amp;proxy, typename ReceiveTag::temporal_id temporal_id, ReceiveDataType &amp;&amp;receive_data, const bool enable_if_disabled) noexcept</td></tr>
<tr class="memdesc:gac776b0d8511f6205734478df6adb2998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send the data <code>args...</code> to the algorithm running on <code>proxy</code>, and tag the message with the identifier <code>temporal_id</code>.  <a href="group__ParallelGroup.html#gac776b0d8511f6205734478df6adb2998">More...</a><br /></td></tr>
<tr class="separator:gac776b0d8511f6205734478df6adb2998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e8876a39575b15ed555ad2bf1c5fcb0"><td class="memTemplParams" colspan="2">template&lt;typename ReceiveTag , typename Proxy , typename ReceiveDataType , Requires&lt; detail::has_ckLocal_method&lt; std::decay_t&lt; Proxy &gt;&gt;::value &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:ga4e8876a39575b15ed555ad2bf1c5fcb0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga4e8876a39575b15ed555ad2bf1c5fcb0">Parallel::receive_data</a> (Proxy &amp;&amp;proxy, typename ReceiveTag::temporal_id temporal_id, ReceiveDataType &amp;&amp;receive_data) noexcept</td></tr>
<tr class="memdesc:ga4e8876a39575b15ed555ad2bf1c5fcb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send the data <code>args...</code> to the algorithm running on <code>proxy</code>, and tag the message with the identifier <code>temporal_id</code>.  <a href="group__ParallelGroup.html#ga4e8876a39575b15ed555ad2bf1c5fcb0">More...</a><br /></td></tr>
<tr class="separator:ga4e8876a39575b15ed555ad2bf1c5fcb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa17acf0ac876ac8cf36dfb939d7aea11"><td class="memTemplParams" colspan="2"><a id="gaa17acf0ac876ac8cf36dfb939d7aea11"></a>
template&lt;typename Action , typename Proxy &gt; </td></tr>
<tr class="memitem:gaa17acf0ac876ac8cf36dfb939d7aea11"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#gaa17acf0ac876ac8cf36dfb939d7aea11">Parallel::simple_action</a> (Proxy &amp;&amp;proxy) noexcept</td></tr>
<tr class="memdesc:gaa17acf0ac876ac8cf36dfb939d7aea11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a simple action on <code>proxy</code> <br /></td></tr>
<tr class="separator:gaa17acf0ac876ac8cf36dfb939d7aea11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8624f46f3a77806a85190891437ee67"><td class="memTemplParams" colspan="2"><a id="gaa8624f46f3a77806a85190891437ee67"></a>
template&lt;typename Action , typename Proxy , typename Arg0 , typename... Args&gt; </td></tr>
<tr class="memitem:gaa8624f46f3a77806a85190891437ee67"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#gaa8624f46f3a77806a85190891437ee67">Parallel::simple_action</a> (Proxy &amp;&amp;proxy, Arg0 &amp;&amp;arg0, Args &amp;&amp;... args) noexcept</td></tr>
<tr class="memdesc:gaa8624f46f3a77806a85190891437ee67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a simple action on <code>proxy</code> <br /></td></tr>
<tr class="separator:gaa8624f46f3a77806a85190891437ee67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9400abf9bfed73781d813df2c1a9f162"><td class="memTemplParams" colspan="2"><a id="ga9400abf9bfed73781d813df2c1a9f162"></a>
template&lt;typename Action , typename Proxy &gt; </td></tr>
<tr class="memitem:ga9400abf9bfed73781d813df2c1a9f162"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#ga9400abf9bfed73781d813df2c1a9f162">Parallel::threaded_action</a> (Proxy &amp;&amp;proxy) noexcept</td></tr>
<tr class="memdesc:ga9400abf9bfed73781d813df2c1a9f162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a threaded action on <code>proxy</code>, where the proxy must be a nodegroup. <br /></td></tr>
<tr class="separator:ga9400abf9bfed73781d813df2c1a9f162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac875d2accf84d68a10b5a9c8b450cb5d"><td class="memTemplParams" colspan="2"><a id="gac875d2accf84d68a10b5a9c8b450cb5d"></a>
template&lt;typename Action , typename Proxy , typename Arg0 , typename... Args&gt; </td></tr>
<tr class="memitem:gac875d2accf84d68a10b5a9c8b450cb5d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ParallelGroup.html#gac875d2accf84d68a10b5a9c8b450cb5d">Parallel::threaded_action</a> (Proxy &amp;&amp;proxy, Arg0 &amp;&amp;arg0, Args &amp;&amp;... args) noexcept</td></tr>
<tr class="memdesc:gac875d2accf84d68a10b5a9c8b450cb5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a threaded action on <code>proxy</code>, where the proxy must be a nodegroup. <br /></td></tr>
<tr class="separator:gac875d2accf84d68a10b5a9c8b450cb5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Functions, classes and documentation related to parallelization and Charm++. </p>
<p>See <a class="el" href="dev_guide_parallelization_foundations.html">Parallelization infrastructure</a> for details. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gade9eecd27ecadb3501ddae591bf07db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade9eecd27ecadb3501ddae591bf07db0">&#9670;&nbsp;</a></span>WRAPPED_PUPable_decl_base_template</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WRAPPED_PUPable_decl_base_template</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">baseClassName, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">className&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;PUPable_decl_base_template(SINGLE_ARG(baseClassName), SINGLE_ARG(className))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark derived template classes as serializable. </p>
<p>Any class that derives off of a class template base class must contain this macro if it is to be serialized. </p>

</div>
</div>
<a id="ga54770b986b9c522da6d651e1be125a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54770b986b9c522da6d651e1be125a03">&#9670;&nbsp;</a></span>WRAPPED_PUPable_decl_template</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WRAPPED_PUPable_decl_template</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">className</td><td>)</td>
          <td>&#160;&#160;&#160;PUPable_decl_template(SINGLE_ARG(className))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark derived classes as serializable. </p>
<p>Any class that derives off of a non-class template base class must contain this macro if it is to be serialized. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga6fb3864413e851ea6dcd1ffa319f2f25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fb3864413e851ea6dcd1ffa319f2f25">&#9670;&nbsp;</a></span>deserialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T deserialize </td>
          <td>(</td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserialize an object using PUP. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type to deserialize to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5650367ede7ee5b92720ed3636df24e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5650367ede7ee5b92720ed3636df24e2">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConstGlobalCacheTag , typename Metavariables &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Parallel::get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParallel_1_1ConstGlobalCache.html">ConstGlobalCache</a>&lt; Metavariables &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em></td><td>)</td>
          <td> -&gt; const
    ConstGlobalCache_detail::type_for_get&lt;ConstGlobalCacheTag, Metavariables&gt;&amp; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access data in the cache. </p>
<p><em>Requires:</em> ConstGlobalCacheTag is a tag in tag_list</p>
<p><em>Returns:</em> a constant reference to an object in the cache </p>

</div>
</div>
<a id="ga267c8d6d5f2313bd05ed69f91485776f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga267c8d6d5f2313bd05ed69f91485776f">&#9670;&nbsp;</a></span>get_parallel_component() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ParallelComponentTag , typename Metavariables &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Parallel::get_parallel_component </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParallel_1_1ConstGlobalCache.html">ConstGlobalCache</a>&lt; Metavariables &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em></td><td>)</td>
          <td> -&gt; Parallel::proxy_from_parallel_component&lt;
        ConstGlobalCache_detail::get_component_if_mocked&lt;
            typename Metavariables::component_list, ParallelComponentTag&gt;&gt;&amp; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the Charm++ proxy associated with a ParallelComponent. </p>
<p><em>Requires:</em> ParallelComponentTag is a tag in component_list</p>
<p><em>Returns:</em> a Charm++ proxy that can be used to call an entry method on the chare(s) </p>

</div>
</div>
<a id="ga992eab06d03182bf63eeeea8880fcf1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga992eab06d03182bf63eeeea8880fcf1f">&#9670;&nbsp;</a></span>get_parallel_component() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ParallelComponentTag , typename Metavariables &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Parallel::get_parallel_component </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParallel_1_1ConstGlobalCache.html">ConstGlobalCache</a>&lt; Metavariables &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em></td><td>)</td>
          <td> -&gt; const Parallel::proxy_from_parallel_component&lt;
        ConstGlobalCache_detail::get_component_if_mocked&lt;
            typename Metavariables::component_list, ParallelComponentTag&gt;&gt;&amp; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the Charm++ proxy associated with a ParallelComponent. </p>
<p><em>Requires:</em> ParallelComponentTag is a tag in component_list</p>
<p><em>Returns:</em> a Charm++ proxy that can be used to call an entry method on the chare(s) </p>

</div>
</div>
<a id="gae21964b5d28608afd21ae090c1c4c073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae21964b5d28608afd21ae090c1c4c073">&#9670;&nbsp;</a></span>printf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parallel::printf </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print an atomic message to stdout with C printf usage. </p>
<p>Similar to Python, you can print any object that's streamable by passing it in as an argument and using the formatter "%s". For example, </p><div class="fragment"><div class="line"><a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a> a{0.8, 73, 9.8};</div><div class="line"><a class="code" href="group__ParallelGroup.html#gae21964b5d28608afd21ae090c1c4c073">Parallel::printf</a>(<span class="stringliteral">&quot;%s\n&quot;</span>, a);</div></div><!-- fragment --> 
</div>
</div>
<a id="gaa8448205dbaf9741505bd30dfad2cadc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8448205dbaf9741505bd30dfad2cadc">&#9670;&nbsp;</a></span>printf_error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parallel::printf_error </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print an atomic message to stderr with C printf usage. </p>
<p>See <a class="el" href="group__ParallelGroup.html#gae21964b5d28608afd21ae090c1c4c073" title="Print an atomic message to stdout with C printf usage. ">Parallel::printf</a> for details. </p>

</div>
</div>
<a id="gac776b0d8511f6205734478df6adb2998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac776b0d8511f6205734478df6adb2998">&#9670;&nbsp;</a></span>receive_data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReceiveTag , typename Proxy , typename ReceiveDataType , Requires&lt; detail::has_ckLocal_method&lt; std::decay_t&lt; Proxy &gt;&gt;::value &gt;  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parallel::receive_data </td>
          <td>(</td>
          <td class="paramtype">Proxy &amp;&amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename ReceiveTag::temporal_id&#160;</td>
          <td class="paramname"><em>temporal_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReceiveDataType &amp;&amp;&#160;</td>
          <td class="paramname"><em>receive_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>enable_if_disabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send the data <code>args...</code> to the algorithm running on <code>proxy</code>, and tag the message with the identifier <code>temporal_id</code>. </p>
<p>If the algorithm was previously disabled, set <code>enable_if_disabled</code> to true to enable the algorithm on the parallel component.</p>
<dl class="section note"><dt>Note</dt><dd>The reason there are two separate functions is because Charm++ does not allow defaulted arguments for group and nodegroup chares. </dd></dl>

</div>
</div>
<a id="ga4e8876a39575b15ed555ad2bf1c5fcb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e8876a39575b15ed555ad2bf1c5fcb0">&#9670;&nbsp;</a></span>receive_data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReceiveTag , typename Proxy , typename ReceiveDataType , Requires&lt; detail::has_ckLocal_method&lt; std::decay_t&lt; Proxy &gt;&gt;::value &gt;  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parallel::receive_data </td>
          <td>(</td>
          <td class="paramtype">Proxy &amp;&amp;&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename ReceiveTag::temporal_id&#160;</td>
          <td class="paramname"><em>temporal_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReceiveDataType &amp;&amp;&#160;</td>
          <td class="paramname"><em>receive_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send the data <code>args...</code> to the algorithm running on <code>proxy</code>, and tag the message with the identifier <code>temporal_id</code>. </p>
<p>If the algorithm was previously disabled, set <code>enable_if_disabled</code> to true to enable the algorithm on the parallel component.</p>
<dl class="section note"><dt>Note</dt><dd>The reason there are two separate functions is because Charm++ does not allow defaulted arguments for group and nodegroup chares. </dd></dl>

</div>
</div>
<a id="gaf46b590510bd8fad34c7055079262707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf46b590510bd8fad34c7055079262707">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;char&gt; serialize </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize an object using PUP. </p>
<p>The type to serialize as must be explicitly specified. We require this because a mismatch between the serialize and deserialize calls causes undefined behavior and we do not want this to depend on inferred types for safety.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type to serialize </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
&copy; Copyright 2017 - 2019
<a href="https://black-holes.org">SXS Collaboration</a>,
<a href="LICENSE.txt" target="_blank">
<span class="hidden-xs">Distributed under the</span>
MIT License</a>
</small></address>
</body>
</html>
